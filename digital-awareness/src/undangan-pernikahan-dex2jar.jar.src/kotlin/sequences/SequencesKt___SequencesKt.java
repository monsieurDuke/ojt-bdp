package kotlin.sequences;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import kotlin.Deprecated;
import kotlin.DeprecatedSinceKotlin;
import kotlin.Metadata;
import kotlin.Pair;
import kotlin.ReplaceWith;
import kotlin.ResultKt;
import kotlin.TuplesKt;
import kotlin.UInt;
import kotlin.ULong;
import kotlin.Unit;
import kotlin.collections.ArraysKt;
import kotlin.collections.BrittleContainsOptimizationKt;
import kotlin.collections.CollectionsKt;
import kotlin.collections.Grouping;
import kotlin.collections.IndexedValue;
import kotlin.collections.SetsKt;
import kotlin.collections.SlidingWindowKt;
import kotlin.comparisons.ComparisonsKt;
import kotlin.comparisons.ComparisonsKt__ComparisonsKt.compareBy.2;
import kotlin.comparisons.ComparisonsKt__ComparisonsKt.compareByDescending.1;
import kotlin.coroutines.Continuation;
import kotlin.coroutines.intrinsics.IntrinsicsKt;
import kotlin.coroutines.jvm.internal.Boxing;
import kotlin.coroutines.jvm.internal.DebugMetadata;
import kotlin.coroutines.jvm.internal.RestrictedSuspendLambda;
import kotlin.jvm.functions.Function1;
import kotlin.jvm.functions.Function2;
import kotlin.jvm.functions.Function3;
import kotlin.jvm.internal.FunctionReferenceImpl;
import kotlin.jvm.internal.Intrinsics;
import kotlin.jvm.internal.Lambda;
import kotlin.jvm.internal.Ref.BooleanRef;
import kotlin.jvm.internal.markers.KMappedMarker;
import kotlin.text.StringsKt;

@Metadata(d1={"\000\002\n\000\n\002\020\013\n\000\n\002\030\002\n\000\n\002\030\002\n\002\b\002\n\002\020\034\n\002\b\002\n\002\020$\n\002\b\003\n\002\030\002\n\002\b\005\n\002\020%\n\002\b\b\n\002\020\006\n\002\020\005\n\002\b\002\n\002\020\007\n\000\n\002\020\b\n\000\n\002\020\t\n\000\n\002\020\n\n\002\b\002\n\002\020 \n\002\b\003\n\002\030\002\n\002\b\022\n\002\030\002\n\002\030\002\n\002\b\003\n\002\020\037\n\002\b\002\n\002\030\002\n\002\b\004\n\002\020\000\n\002\b\034\n\002\030\002\n\002\b\002\n\002\020\002\n\002\b\004\n\002\020!\n\000\n\002\030\002\n\002\b\006\n\002\030\002\n\002\030\002\n\002\b\002\n\002\020\r\n\002\b\006\n\002\020\016\n\002\b\f\n\002\020\017\n\002\b\f\n\002\030\002\n\002\030\002\n\002\b\031\n\002\020\021\n\002\b)\n\002\030\002\n\002\b\002\n\002\030\002\n\002\b\006\n\002\030\002\n\002\030\002\n\002\b\003\n\002\020#\n\000\n\002\020\"\n\002\b\004\n\002\030\002\n\002\b\006\0320\020\000\032\0020\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000\032\026\020\006\032\0020\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\0320\020\006\032\0020\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000\032\034\020\007\032\b\022\004\022\002H\0020\b\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\032\037\020\t\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\003H\b\032T\020\n\032\016\022\004\022\002H\f\022\004\022\002H\r0\013\"\004\b\000\020\002\"\004\b\001\020\f\"\004\b\002\020\r*\b\022\004\022\002H\0020\0032\036\020\016\032\032\022\004\022\002H\002\022\020\022\016\022\004\022\002H\f\022\004\022\002H\r0\0170\005H\bø\001\000\032B\020\020\032\016\022\004\022\002H\f\022\004\022\002H\0020\013\"\004\b\000\020\002\"\004\b\001\020\f*\b\022\004\022\002H\0020\0032\022\020\021\032\016\022\004\022\002H\002\022\004\022\002H\f0\005H\bø\001\000\032\\\020\020\032\016\022\004\022\002H\f\022\004\022\002H\r0\013\"\004\b\000\020\002\"\004\b\001\020\f\"\004\b\002\020\r*\b\022\004\022\002H\0020\0032\022\020\021\032\016\022\004\022\002H\002\022\004\022\002H\f0\0052\022\020\022\032\016\022\004\022\002H\002\022\004\022\002H\r0\005H\bø\001\000\032]\020\023\032\002H\024\"\004\b\000\020\002\"\004\b\001\020\f\"\030\b\002\020\024*\022\022\006\b\000\022\002H\f\022\006\b\000\022\002H\0020\025*\b\022\004\022\002H\0020\0032\006\020\026\032\002H\0242\022\020\021\032\016\022\004\022\002H\002\022\004\022\002H\f0\005H\bø\001\000¢\006\002\020\027\032w\020\023\032\002H\024\"\004\b\000\020\002\"\004\b\001\020\f\"\004\b\002\020\r\"\030\b\003\020\024*\022\022\006\b\000\022\002H\f\022\006\b\000\022\002H\r0\025*\b\022\004\022\002H\0020\0032\006\020\026\032\002H\0242\022\020\021\032\016\022\004\022\002H\002\022\004\022\002H\f0\0052\022\020\022\032\016\022\004\022\002H\002\022\004\022\002H\r0\005H\bø\001\000¢\006\002\020\030\032o\020\031\032\002H\024\"\004\b\000\020\002\"\004\b\001\020\f\"\004\b\002\020\r\"\030\b\003\020\024*\022\022\006\b\000\022\002H\f\022\006\b\000\022\002H\r0\025*\b\022\004\022\002H\0020\0032\006\020\026\032\002H\0242\036\020\016\032\032\022\004\022\002H\002\022\020\022\016\022\004\022\002H\f\022\004\022\002H\r0\0170\005H\bø\001\000¢\006\002\020\027\032B\020\032\032\016\022\004\022\002H\f\022\004\022\002H\r0\013\"\004\b\000\020\f\"\004\b\001\020\r*\b\022\004\022\002H\f0\0032\022\020\033\032\016\022\004\022\002H\f\022\004\022\002H\r0\005H\bø\001\000\032]\020\034\032\002H\024\"\004\b\000\020\f\"\004\b\001\020\r\"\030\b\002\020\024*\022\022\006\b\000\022\002H\f\022\006\b\000\022\002H\r0\025*\b\022\004\022\002H\f0\0032\006\020\026\032\002H\0242\022\020\033\032\016\022\004\022\002H\f\022\004\022\002H\r0\005H\bø\001\000¢\006\002\020\027\032\027\020\035\032\0020\036*\b\022\004\022\0020\0370\003H\007¢\006\002\b \032\027\020\035\032\0020\036*\b\022\004\022\0020\0360\003H\007¢\006\002\b!\032\027\020\035\032\0020\036*\b\022\004\022\0020\"0\003H\007¢\006\002\b#\032\027\020\035\032\0020\036*\b\022\004\022\0020$0\003H\007¢\006\002\b%\032\027\020\035\032\0020\036*\b\022\004\022\0020&0\003H\007¢\006\002\b'\032\027\020\035\032\0020\036*\b\022\004\022\0020(0\003H\007¢\006\002\b)\032,\020*\032\016\022\n\022\b\022\004\022\002H\0020+0\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\020,\032\0020$H\007\032F\020*\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\006\020,\032\0020$2\030\020\016\032\024\022\n\022\b\022\004\022\002H\0020+\022\004\022\002H-0\005H\007\032+\020.\032\0020\001\"\t\b\000\020\002¢\006\002\b/*\b\022\004\022\002H\0020\0032\006\0200\032\002H\002H\002¢\006\002\0201\032\026\0202\032\0020$\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\0320\0202\032\0020$\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000\032\034\0203\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\0326\0204\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002\"\004\b\001\020\f*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\002H\f0\005\032$\0206\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\0207\032\0020$\0320\0208\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005\032#\0209\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\020:\032\0020$¢\006\002\020;\0327\020<\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\020:\032\0020$2\022\020=\032\016\022\004\022\0020$\022\004\022\002H\0020\005¢\006\002\020>\032%\020?\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\020:\032\0020$¢\006\002\020;\0320\020@\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005\032E\020A\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032'\020\004\032#\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\004\022\0020\0010B\032d\020E\032\002HF\"\004\b\000\020\002\"\020\b\001\020F*\n\022\006\b\000\022\002H\0020G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2'\020\004\032#\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\004\022\0020\0010BH\bø\001\000¢\006\002\020H\032$\020I\032\r\022\t\022\007H-¢\006\002\bJ0\003\"\006\b\000\020-\030\001*\006\022\002\b\0030\003H\b\0328\020K\032\002HF\"\006\b\000\020-\030\001\"\020\b\001\020F*\n\022\006\b\000\022\002H-0G*\006\022\002\b\0030\0032\006\020\026\032\002HFH\b¢\006\002\020L\0320\020M\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005\032\"\020N\032\b\022\004\022\002H\0020\003\"\b\b\000\020\002*\0020O*\n\022\006\022\004\030\001H\0020\003\032;\020P\032\002HF\"\020\b\000\020F*\n\022\006\b\000\022\002H\0020G\"\b\b\001\020\002*\0020O*\n\022\006\022\004\030\001H\0020\0032\006\020\026\032\002HF¢\006\002\020L\032O\020Q\032\002HF\"\004\b\000\020\002\"\020\b\001\020F*\n\022\006\b\000\022\002H\0020G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020R\032O\020S\032\002HF\"\004\b\000\020\002\"\020\b\001\020F*\n\022\006\b\000\022\002H\0020G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020R\0327\020T\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020U\0327\020V\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020U\032\033\020W\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\003¢\006\002\020X\0325\020W\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020U\032A\020Y\032\002H-\"\004\b\000\020\002\"\b\b\001\020-*\0020O*\b\022\004\022\002H\0020\0032\024\020\016\032\020\022\004\022\002H\002\022\006\022\004\030\001H-0\005H\bø\001\000¢\006\002\020U\032C\020Z\032\004\030\001H-\"\004\b\000\020\002\"\b\b\001\020-*\0020O*\b\022\004\022\002H\0020\0032\024\020\016\032\020\022\004\022\002H\002\022\006\022\004\030\001H-0\005H\bø\001\000¢\006\002\020U\032\035\020[\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\003¢\006\002\020X\0327\020[\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020U\032C\020\\\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\030\020\016\032\024\022\004\022\002H\002\022\n\022\b\022\004\022\002H-0\b0\005H\007¢\006\002\b]\032<\020\\\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\030\020\016\032\024\022\004\022\002H\002\022\n\022\b\022\004\022\002H-0\0030\005\032X\020^\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032-\020\016\032)\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\n\022\b\022\004\022\002H-0\b0BH\007¢\006\002\b_\032X\020^\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032-\020\016\032)\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\n\022\b\022\004\022\002H-0\0030BH\007¢\006\002\b`\032r\020a\032\002HF\"\004\b\000\020\002\"\004\b\001\020-\"\020\b\002\020F*\n\022\006\b\000\022\002H-0G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2-\020\016\032)\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\n\022\b\022\004\022\002H-0\b0BH\bø\001\000¢\006\004\bb\020H\032r\020a\032\002HF\"\004\b\000\020\002\"\004\b\001\020-\"\020\b\002\020F*\n\022\006\b\000\022\002H-0G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2-\020\016\032)\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\n\022\b\022\004\022\002H-0\0030BH\bø\001\000¢\006\004\bc\020H\032]\020d\032\002HF\"\004\b\000\020\002\"\004\b\001\020-\"\020\b\002\020F*\n\022\006\b\000\022\002H-0G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2\030\020\016\032\024\022\004\022\002H\002\022\n\022\b\022\004\022\002H-0\b0\005H\bø\001\000¢\006\004\be\020R\032[\020d\032\002HF\"\004\b\000\020\002\"\004\b\001\020-\"\020\b\002\020F*\n\022\006\b\000\022\002H-0G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2\030\020\016\032\024\022\004\022\002H\002\022\n\022\b\022\004\022\002H-0\0030\005H\bø\001\000¢\006\002\020R\032X\020f\032\002H-\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\006\020g\032\002H-2'\020h\032#\022\023\022\021H-¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\004\022\002H-0BH\bø\001\000¢\006\002\020j\032m\020k\032\002H-\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\006\020g\032\002H-2<\020h\0328\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\023\022\021H-¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\004\022\002H-0lH\bø\001\000¢\006\002\020m\0320\020n\032\0020o\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020p\032\016\022\004\022\002H\002\022\004\022\0020o0\005H\bø\001\000\032E\020q\032\0020o\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032'\020p\032#\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\004\022\0020o0BH\bø\001\000\032H\020r\032\024\022\004\022\002H\f\022\n\022\b\022\004\022\002H\0020+0\013\"\004\b\000\020\002\"\004\b\001\020\f*\b\022\004\022\002H\0020\0032\022\020\021\032\016\022\004\022\002H\002\022\004\022\002H\f0\005H\bø\001\000\032b\020r\032\024\022\004\022\002H\f\022\n\022\b\022\004\022\002H\r0+0\013\"\004\b\000\020\002\"\004\b\001\020\f\"\004\b\002\020\r*\b\022\004\022\002H\0020\0032\022\020\021\032\016\022\004\022\002H\002\022\004\022\002H\f0\0052\022\020\022\032\016\022\004\022\002H\002\022\004\022\002H\r0\005H\bø\001\000\032a\020s\032\002H\024\"\004\b\000\020\002\"\004\b\001\020\f\"\034\b\002\020\024*\026\022\006\b\000\022\002H\f\022\n\022\b\022\004\022\002H\0020t0\025*\b\022\004\022\002H\0020\0032\006\020\026\032\002H\0242\022\020\021\032\016\022\004\022\002H\002\022\004\022\002H\f0\005H\bø\001\000¢\006\002\020\027\032{\020s\032\002H\024\"\004\b\000\020\002\"\004\b\001\020\f\"\004\b\002\020\r\"\034\b\003\020\024*\026\022\006\b\000\022\002H\f\022\n\022\b\022\004\022\002H\r0t0\025*\b\022\004\022\002H\0020\0032\006\020\026\032\002H\0242\022\020\021\032\016\022\004\022\002H\002\022\004\022\002H\f0\0052\022\020\022\032\016\022\004\022\002H\002\022\004\022\002H\r0\005H\bø\001\000¢\006\002\020\030\032D\020u\032\016\022\004\022\002H\002\022\004\022\002H\f0v\"\004\b\000\020\002\"\004\b\001\020\f*\b\022\004\022\002H\0020\0032\024\b\004\020\021\032\016\022\004\022\002H\002\022\004\022\002H\f0\005H\bø\001\000\032(\020w\032\0020$\"\t\b\000\020\002¢\006\002\b/*\b\022\004\022\002H\0020\0032\006\0200\032\002H\002¢\006\002\020x\0320\020y\032\0020$\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000\0320\020z\032\0020$\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000\032\001\020{\032\002H|\"\004\b\000\020\002\"\f\b\001\020|*\0060}j\002`~*\b\022\004\022\002H\0020\0032\006\020\032\002H|2\n\b\002\020\001\032\0030\0012\n\b\002\020\001\032\0030\0012\n\b\002\020\001\032\0030\0012\t\b\002\020\001\032\0020$2\n\b\002\020\001\032\0030\0012\027\b\002\020\016\032\021\022\004\022\002H\002\022\005\022\0030\001\030\0010\005¢\006\003\020\001\032l\020\001\032\0030\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\n\b\002\020\001\032\0030\0012\n\b\002\020\001\032\0030\0012\n\b\002\020\001\032\0030\0012\t\b\002\020\001\032\0020$2\n\b\002\020\001\032\0030\0012\027\b\002\020\016\032\021\022\004\022\002H\002\022\005\022\0030\001\030\0010\005\032\034\020\001\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\003¢\006\002\020X\0326\020\001\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020U\032)\020\001\032\0020$\"\t\b\000\020\002¢\006\002\b/*\b\022\004\022\002H\0020\0032\006\0200\032\002H\002¢\006\002\020x\032\036\020\001\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\003¢\006\002\020X\0328\020\001\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020U\0327\020\001\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\022\020\016\032\016\022\004\022\002H\002\022\004\022\002H-0\005\032L\020\001\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032'\020\016\032#\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\004\022\002H-0B\032R\020\001\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\b\b\001\020-*\0020O*\b\022\004\022\002H\0020\0032)\020\016\032%\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\006\022\004\030\001H-0B\032q\020\001\032\002HF\"\004\b\000\020\002\"\b\b\001\020-*\0020O\"\020\b\002\020F*\n\022\006\b\000\022\002H-0G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2)\020\016\032%\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\006\022\004\030\001H-0BH\bø\001\000¢\006\002\020H\032k\020\001\032\002HF\"\004\b\000\020\002\"\004\b\001\020-\"\020\b\002\020F*\n\022\006\b\000\022\002H-0G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2'\020\016\032#\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\004\022\002H-0BH\bø\001\000¢\006\002\020H\032=\020\001\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\b\b\001\020-*\0020O*\b\022\004\022\002H\0020\0032\024\020\016\032\020\022\004\022\002H\002\022\006\022\004\030\001H-0\005\032\\\020\001\032\002HF\"\004\b\000\020\002\"\b\b\001\020-*\0020O\"\020\b\002\020F*\n\022\006\b\000\022\002H-0G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2\024\020\016\032\020\022\004\022\002H\002\022\006\022\004\030\001H-0\005H\bø\001\000¢\006\002\020R\032V\020\001\032\002HF\"\004\b\000\020\002\"\004\b\001\020-\"\020\b\002\020F*\n\022\006\b\000\022\002H-0G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF2\022\020\016\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\002\020R\032-\020\001\032\002H\002\"\017\b\000\020\002*\t\022\004\022\002H\0020\001*\b\022\004\022\002H\0020\003H\007¢\006\006\b\001\020\001\032\031\020\001\032\0020\036*\b\022\004\022\0020\0360\003H\007¢\006\003\b\001\032\031\020\001\032\0020\"*\b\022\004\022\0020\"0\003H\007¢\006\003\b\001\032J\020\001\032\002H\002\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\005\b\001\020U\032I\020\001\032\004\030\001H\002\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\002\020U\032H\020\001\032\002H-\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\003\020\001\0321\020\001\032\0020\036\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\0360\005H\bø\001\000\0321\020\001\032\0020\"\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\"0\005H\bø\001\000\032J\020\001\032\004\030\001H-\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\003\020\001\0329\020\001\032\004\030\0010\036\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\0360\005H\bø\001\000¢\006\003\020\001\0329\020\001\032\004\030\0010\"\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\"0\005H\bø\001\000¢\006\003\020\001\032\\\020 \001\032\002H-\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\035\020¡\001\032\030\022\006\b\000\022\002H-0¢\001j\013\022\006\b\000\022\002H-`£\0012\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\003\020¤\001\032^\020¥\001\032\004\030\001H-\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\035\020¡\001\032\030\022\006\b\000\022\002H-0¢\001j\013\022\006\b\000\022\002H-`£\0012\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\003\020¤\001\032,\020¦\001\032\004\030\001H\002\"\017\b\000\020\002*\t\022\004\022\002H\0020\001*\b\022\004\022\002H\0020\003H\007¢\006\003\020\001\032\033\020¦\001\032\004\030\0010\036*\b\022\004\022\0020\0360\003H\007¢\006\003\020§\001\032\033\020¦\001\032\004\030\0010\"*\b\022\004\022\0020\"0\003H\007¢\006\003\020¨\001\032A\020©\001\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\035\020¡\001\032\030\022\006\b\000\022\002H\0020¢\001j\013\022\006\b\000\022\002H\002`£\001H\007¢\006\006\bª\001\020«\001\032@\020¬\001\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\035\020¡\001\032\030\022\006\b\000\022\002H\0020¢\001j\013\022\006\b\000\022\002H\002`£\001H\007¢\006\003\020«\001\032-\020­\001\032\002H\002\"\017\b\000\020\002*\t\022\004\022\002H\0020\001*\b\022\004\022\002H\0020\003H\007¢\006\006\b®\001\020\001\032\031\020­\001\032\0020\036*\b\022\004\022\0020\0360\003H\007¢\006\003\b®\001\032\031\020­\001\032\0020\"*\b\022\004\022\0020\"0\003H\007¢\006\003\b®\001\032J\020¯\001\032\002H\002\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\005\b°\001\020U\032I\020±\001\032\004\030\001H\002\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\002\020U\032H\020²\001\032\002H-\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\003\020\001\0321\020²\001\032\0020\036\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\0360\005H\bø\001\000\0321\020²\001\032\0020\"\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\"0\005H\bø\001\000\032J\020³\001\032\004\030\001H-\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\003\020\001\0329\020³\001\032\004\030\0010\036\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\0360\005H\bø\001\000¢\006\003\020\001\0329\020³\001\032\004\030\0010\"\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\"0\005H\bø\001\000¢\006\003\020\001\032\\\020´\001\032\002H-\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\035\020¡\001\032\030\022\006\b\000\022\002H-0¢\001j\013\022\006\b\000\022\002H-`£\0012\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\003\020¤\001\032^\020µ\001\032\004\030\001H-\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\035\020¡\001\032\030\022\006\b\000\022\002H-0¢\001j\013\022\006\b\000\022\002H-`£\0012\022\0205\032\016\022\004\022\002H\002\022\004\022\002H-0\005H\bø\001\000¢\006\003\020¤\001\032,\020¶\001\032\004\030\001H\002\"\017\b\000\020\002*\t\022\004\022\002H\0020\001*\b\022\004\022\002H\0020\003H\007¢\006\003\020\001\032\033\020¶\001\032\004\030\0010\036*\b\022\004\022\0020\0360\003H\007¢\006\003\020§\001\032\033\020¶\001\032\004\030\0010\"*\b\022\004\022\0020\"0\003H\007¢\006\003\020¨\001\032A\020·\001\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\035\020¡\001\032\030\022\006\b\000\022\002H\0020¢\001j\013\022\006\b\000\022\002H\002`£\001H\007¢\006\006\b¸\001\020«\001\032@\020¹\001\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\035\020¡\001\032\030\022\006\b\000\022\002H\0020¢\001j\013\022\006\b\000\022\002H\002`£\001H\007¢\006\003\020«\001\032.\020º\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\0200\032\002H\002H\002¢\006\003\020»\001\0328\020º\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\020\020¼\001\032\013\022\006\b\001\022\002H\0020½\001H\002¢\006\003\020¾\001\032/\020º\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\r\020¼\001\032\b\022\004\022\002H\0020\bH\002\032/\020º\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\r\020¼\001\032\b\022\004\022\002H\0020\003H\002\032.\020¿\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\0200\032\002H\002H\b¢\006\003\020»\001\032\027\020À\001\032\0020\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\0321\020À\001\032\0020\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000\0323\020Á\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020p\032\016\022\004\022\002H\002\022\004\022\0020o0\005H\007\032H\020Â\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032'\020p\032#\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\004\022\002H\002\022\004\022\0020o0BH\007\032I\020Ã\001\032\032\022\n\022\b\022\004\022\002H\0020+\022\n\022\b\022\004\022\002H\0020+0\017\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000\032.\020Ä\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\0200\032\002H\002H\002¢\006\003\020»\001\0328\020Ä\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\020\020¼\001\032\013\022\006\b\001\022\002H\0020½\001H\002¢\006\003\020¾\001\032/\020Ä\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\r\020¼\001\032\b\022\004\022\002H\0020\bH\002\032/\020Ä\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\r\020¼\001\032\b\022\004\022\002H\0020\003H\002\032.\020Å\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\0200\032\002H\002H\b¢\006\003\020»\001\032[\020Æ\001\032\003HÇ\001\"\005\b\000\020Ç\001\"\t\b\001\020\002*\003HÇ\001*\b\022\004\022\002H\0020\0032)\020h\032%\022\024\022\022HÇ\001¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\005\022\003HÇ\0010BH\bø\001\000¢\006\003\020È\001\032p\020É\001\032\003HÇ\001\"\005\b\000\020Ç\001\"\t\b\001\020\002*\003HÇ\001*\b\022\004\022\002H\0020\0032>\020h\032:\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\024\022\022HÇ\001¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\005\022\003HÇ\0010lH\bø\001\000¢\006\003\020Ê\001\032r\020Ë\001\032\005\030\001HÇ\001\"\005\b\000\020Ç\001\"\t\b\001\020\002*\003HÇ\001*\b\022\004\022\002H\0020\0032>\020h\032:\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\024\022\022HÇ\001¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\005\022\003HÇ\0010lH\bø\001\000¢\006\003\020Ê\001\032]\020Ì\001\032\005\030\001HÇ\001\"\005\b\000\020Ç\001\"\t\b\001\020\002*\003HÇ\001*\b\022\004\022\002H\0020\0032)\020h\032%\022\024\022\022HÇ\001¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\005\022\003HÇ\0010BH\bø\001\000¢\006\003\020È\001\032#\020Í\001\032\b\022\004\022\002H\0020\003\"\b\b\000\020\002*\0020O*\n\022\006\022\004\030\001H\0020\003\032\\\020Î\001\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\006\020g\032\002H-2'\020h\032#\022\023\022\021H-¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\004\022\002H-0BH\007¢\006\003\020Ï\001\032q\020Ð\001\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\006\020g\032\002H-2<\020h\0328\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\023\022\021H-¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\004\022\002H-0lH\007¢\006\003\020Ñ\001\032W\020Ò\001\032\t\022\005\022\003HÇ\0010\003\"\005\b\000\020Ç\001\"\t\b\001\020\002*\003HÇ\001*\b\022\004\022\002H\0020\0032)\020h\032%\022\024\022\022HÇ\001¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\005\022\003HÇ\0010BH\007\032l\020Ó\001\032\t\022\005\022\003HÇ\0010\003\"\005\b\000\020Ç\001\"\t\b\001\020\002*\003HÇ\001*\b\022\004\022\002H\0020\0032>\020h\032:\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\024\022\022HÇ\001¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\005\022\003HÇ\0010lH\007\032\\\020Ô\001\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\006\020g\032\002H-2'\020h\032#\022\023\022\021H-¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\004\022\002H-0BH\007¢\006\003\020Ï\001\032q\020Õ\001\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\006\020g\032\002H-2<\020h\0328\022\023\022\0210$¢\006\f\bC\022\b\bD\022\004\b\b(:\022\023\022\021H-¢\006\f\bC\022\b\bD\022\004\b\b(i\022\004\022\002H\002\022\004\022\002H-0lH\007¢\006\003\020Ñ\001\032\034\020Ö\001\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\003¢\006\002\020X\0326\020Ö\001\032\002H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020U\032\036\020×\001\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\003¢\006\002\020X\0328\020×\001\032\004\030\001H\002\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005H\bø\001\000¢\006\002\020U\032(\020Ø\001\032\b\022\004\022\002H\0020\003\"\017\b\000\020\002*\t\022\004\022\002H\0020\001*\b\022\004\022\002H\0020\003\032L\020Ù\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\026\b\004\0205\032\020\022\004\022\002H\002\022\006\022\004\030\001H-0\005H\bø\001\000\032L\020Ú\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002\"\017\b\001\020-*\t\022\004\022\002H-0\001*\b\022\004\022\002H\0020\0032\026\b\004\0205\032\020\022\004\022\002H\002\022\006\022\004\030\001H-0\005H\bø\001\000\032(\020Û\001\032\b\022\004\022\002H\0020\003\"\017\b\000\020\002*\t\022\004\022\002H\0020\001*\b\022\004\022\002H\0020\003\032<\020Ü\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\035\020¡\001\032\030\022\006\b\000\022\002H\0020¢\001j\013\022\006\b\000\022\002H\002`£\001\032\031\020Ý\001\032\0020$*\b\022\004\022\0020\0370\003H\007¢\006\003\bÞ\001\032\031\020Ý\001\032\0020\036*\b\022\004\022\0020\0360\003H\007¢\006\003\bß\001\032\031\020Ý\001\032\0020\"*\b\022\004\022\0020\"0\003H\007¢\006\003\bà\001\032\031\020Ý\001\032\0020$*\b\022\004\022\0020$0\003H\007¢\006\003\bá\001\032\031\020Ý\001\032\0020&*\b\022\004\022\0020&0\003H\007¢\006\003\bâ\001\032\031\020Ý\001\032\0020$*\b\022\004\022\0020(0\003H\007¢\006\003\bã\001\0321\020ä\001\032\0020$\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020$0\005H\bø\001\000\0321\020å\001\032\0020\036\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\0360\005H\bø\001\000\0327\020æ\001\032\0020\036\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020\0360\005H\bø\001\000¢\006\003\bß\001\0327\020æ\001\032\0020$\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020$0\005H\bø\001\000¢\006\003\bá\001\0327\020æ\001\032\0020&\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\0205\032\016\022\004\022\002H\002\022\004\022\0020&0\005H\bø\001\000¢\006\003\bâ\001\032?\020æ\001\032\0030ç\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\023\0205\032\017\022\004\022\002H\002\022\005\022\0030ç\0010\005H\bø\001\000ø\001\001¢\006\006\bè\001\020é\001\032?\020æ\001\032\0030ê\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\023\0205\032\017\022\004\022\002H\002\022\005\022\0030ê\0010\005H\bø\001\000ø\001\001¢\006\006\bë\001\020ì\001\032%\020í\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\0207\032\0020$\0321\020î\001\032\b\022\004\022\002H\0020\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\022\020\004\032\016\022\004\022\002H\002\022\004\022\0020\0010\005\0326\020ï\001\032\002HF\"\004\b\000\020\002\"\020\b\001\020F*\n\022\006\b\000\022\002H\0020G*\b\022\004\022\002H\0020\0032\006\020\026\032\002HF¢\006\002\020L\032)\020ð\001\032\024\022\004\022\002H\0020ñ\001j\t\022\004\022\002H\002`ò\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\032\035\020ó\001\032\b\022\004\022\002H\0020+\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\032\035\020ô\001\032\b\022\004\022\002H\0020t\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\032\036\020õ\001\032\t\022\004\022\002H\0020ö\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\032\036\020÷\001\032\t\022\004\022\002H\0020ø\001\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\032C\020ù\001\032\016\022\n\022\b\022\004\022\002H\0020+0\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\0032\006\020,\032\0020$2\t\b\002\020ú\001\032\0020$2\t\b\002\020û\001\032\0020\001H\007\032]\020ù\001\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\006\020,\032\0020$2\t\b\002\020ú\001\032\0020$2\t\b\002\020û\001\032\0020\0012\030\020\016\032\024\022\n\022\b\022\004\022\002H\0020+\022\004\022\002H-0\005H\007\032$\020ü\001\032\017\022\013\022\t\022\004\022\002H\0020ý\0010\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\003\032A\020þ\001\032\024\022\020\022\016\022\004\022\002H\002\022\004\022\002H-0\0170\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\0032\r\020ÿ\001\032\b\022\004\022\002H-0\003H\004\032r\020þ\001\032\b\022\004\022\002H\r0\003\"\004\b\000\020\002\"\004\b\001\020-\"\004\b\002\020\r*\b\022\004\022\002H\0020\0032\r\020ÿ\001\032\b\022\004\022\002H-0\00328\020\016\0324\022\024\022\022H\002¢\006\r\bC\022\t\bD\022\005\b\b(\002\022\024\022\022H-¢\006\r\bC\022\t\bD\022\005\b\b(\002\022\004\022\002H\r0B\032+\020\002\032\024\022\020\022\016\022\004\022\002H\002\022\004\022\002H\0020\0170\003\"\004\b\000\020\002*\b\022\004\022\002H\0020\003H\007\032_\020\002\032\b\022\004\022\002H-0\003\"\004\b\000\020\002\"\004\b\001\020-*\b\022\004\022\002H\0020\00328\020\016\0324\022\024\022\022H\002¢\006\r\bC\022\t\bD\022\005\b\b(\002\022\024\022\022H\002¢\006\r\bC\022\t\bD\022\005\b\b(\002\022\004\022\002H-0BH\007\002\013\n\005\b20\001\n\002\b\031¨\006\002"}, d2={"all", "", "T", "Lkotlin/sequences/Sequence;", "predicate", "Lkotlin/Function1;", "any", "asIterable", "", "asSequence", "associate", "", "K", "V", "transform", "Lkotlin/Pair;", "associateBy", "keySelector", "valueTransform", "associateByTo", "M", "", "destination", "(Lkotlin/sequences/Sequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;", "(Lkotlin/sequences/Sequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;", "associateTo", "associateWith", "valueSelector", "associateWithTo", "average", "", "", "averageOfByte", "averageOfDouble", "", "averageOfFloat", "", "averageOfInt", "", "averageOfLong", "", "averageOfShort", "chunked", "", "size", "R", "contains", "Lkotlin/internal/OnlyInputTypes;", "element", "(Lkotlin/sequences/Sequence;Ljava/lang/Object;)Z", "count", "distinct", "distinctBy", "selector", "drop", "n", "dropWhile", "elementAt", "index", "(Lkotlin/sequences/Sequence;I)Ljava/lang/Object;", "elementAtOrElse", "defaultValue", "(Lkotlin/sequences/Sequence;ILkotlin/jvm/functions/Function1;)Ljava/lang/Object;", "elementAtOrNull", "filter", "filterIndexed", "Lkotlin/Function2;", "Lkotlin/ParameterName;", "name", "filterIndexedTo", "C", "", "(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;", "filterIsInstance", "Lkotlin/internal/NoInfer;", "filterIsInstanceTo", "(Lkotlin/sequences/Sequence;Ljava/util/Collection;)Ljava/util/Collection;", "filterNot", "filterNotNull", "", "filterNotNullTo", "filterNotTo", "(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;", "filterTo", "find", "(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;", "findLast", "first", "(Lkotlin/sequences/Sequence;)Ljava/lang/Object;", "firstNotNullOf", "firstNotNullOfOrNull", "firstOrNull", "flatMap", "flatMapIterable", "flatMapIndexed", "flatMapIndexedIterable", "flatMapIndexedSequence", "flatMapIndexedTo", "flatMapIndexedIterableTo", "flatMapIndexedSequenceTo", "flatMapTo", "flatMapIterableTo", "fold", "initial", "operation", "acc", "(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;", "foldIndexed", "Lkotlin/Function3;", "(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;", "forEach", "", "action", "forEachIndexed", "groupBy", "groupByTo", "", "groupingBy", "Lkotlin/collections/Grouping;", "indexOf", "(Lkotlin/sequences/Sequence;Ljava/lang/Object;)I", "indexOfFirst", "indexOfLast", "joinTo", "A", "Ljava/lang/Appendable;", "Lkotlin/text/Appendable;", "buffer", "separator", "", "prefix", "postfix", "limit", "truncated", "(Lkotlin/sequences/Sequence;Ljava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;", "joinToString", "", "last", "lastIndexOf", "lastOrNull", "map", "mapIndexed", "mapIndexedNotNull", "mapIndexedNotNullTo", "mapIndexedTo", "mapNotNull", "mapNotNullTo", "mapTo", "max", "", "maxOrThrow", "(Lkotlin/sequences/Sequence;)Ljava/lang/Comparable;", "maxBy", "maxByOrThrow", "maxByOrNull", "maxOf", "(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;", "maxOfOrNull", "(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;", "(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;", "maxOfWith", "comparator", "Ljava/util/Comparator;", "Lkotlin/Comparator;", "(Lkotlin/sequences/Sequence;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;", "maxOfWithOrNull", "maxOrNull", "(Lkotlin/sequences/Sequence;)Ljava/lang/Double;", "(Lkotlin/sequences/Sequence;)Ljava/lang/Float;", "maxWith", "maxWithOrThrow", "(Lkotlin/sequences/Sequence;Ljava/util/Comparator;)Ljava/lang/Object;", "maxWithOrNull", "min", "minOrThrow", "minBy", "minByOrThrow", "minByOrNull", "minOf", "minOfOrNull", "minOfWith", "minOfWithOrNull", "minOrNull", "minWith", "minWithOrThrow", "minWithOrNull", "minus", "(Lkotlin/sequences/Sequence;Ljava/lang/Object;)Lkotlin/sequences/Sequence;", "elements", "", "(Lkotlin/sequences/Sequence;[Ljava/lang/Object;)Lkotlin/sequences/Sequence;", "minusElement", "none", "onEach", "onEachIndexed", "partition", "plus", "plusElement", "reduce", "S", "(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;", "reduceIndexed", "(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;", "reduceIndexedOrNull", "reduceOrNull", "requireNoNulls", "runningFold", "(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;", "runningFoldIndexed", "(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Lkotlin/sequences/Sequence;", "runningReduce", "runningReduceIndexed", "scan", "scanIndexed", "single", "singleOrNull", "sorted", "sortedBy", "sortedByDescending", "sortedDescending", "sortedWith", "sum", "sumOfByte", "sumOfDouble", "sumOfFloat", "sumOfInt", "sumOfLong", "sumOfShort", "sumBy", "sumByDouble", "sumOf", "Lkotlin/UInt;", "sumOfUInt", "(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)I", "Lkotlin/ULong;", "sumOfULong", "(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)J", "take", "takeWhile", "toCollection", "toHashSet", "Ljava/util/HashSet;", "Lkotlin/collections/HashSet;", "toList", "toMutableList", "toMutableSet", "", "toSet", "", "windowed", "step", "partialWindows", "withIndex", "Lkotlin/collections/IndexedValue;", "zip", "other", "a", "b", "zipWithNext", "kotlin-stdlib"}, k=5, mv={1, 7, 1}, xi=49, xs="kotlin/sequences/SequencesKt")
class SequencesKt___SequencesKt
  extends SequencesKt___SequencesJvmKt
{
  public static final <T> boolean all(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      if (!((Boolean)paramFunction1.invoke(paramSequence.next())).booleanValue()) {
        return false;
      }
    }
    return true;
  }
  
  public static final <T> boolean any(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return paramSequence.iterator().hasNext();
  }
  
  public static final <T> boolean any(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      if (((Boolean)paramFunction1.invoke(paramSequence.next())).booleanValue()) {
        return true;
      }
    }
    return false;
  }
  
  public static final <T> Iterable<T> asIterable(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    (Iterable)new Iterable()
    {
      final Sequence $this_asIterable$inlined;
      
      public Iterator<T> iterator()
      {
        return this.$this_asIterable$inlined.iterator();
      }
    };
  }
  
  private static final <T> Sequence<T> asSequence(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return paramSequence;
  }
  
  public static final <T, K, V> Map<K, V> associate(Sequence<? extends T> paramSequence, Function1<? super T, ? extends Pair<? extends K, ? extends V>> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    Map localMap = (Map)new LinkedHashMap();
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Pair localPair = (Pair)paramFunction1.invoke(paramSequence.next());
      localMap.put(localPair.getFirst(), localPair.getSecond());
    }
    return localMap;
  }
  
  public static final <T, K> Map<K, T> associateBy(Sequence<? extends T> paramSequence, Function1<? super T, ? extends K> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "keySelector");
    Map localMap = (Map)new LinkedHashMap();
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      localMap.put(paramFunction1.invoke(paramSequence), paramSequence);
    }
    return localMap;
  }
  
  public static final <T, K, V> Map<K, V> associateBy(Sequence<? extends T> paramSequence, Function1<? super T, ? extends K> paramFunction1, Function1<? super T, ? extends V> paramFunction11)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "keySelector");
    Intrinsics.checkNotNullParameter(paramFunction11, "valueTransform");
    Map localMap = (Map)new LinkedHashMap();
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      localMap.put(paramFunction1.invoke(localObject), paramFunction11.invoke(localObject));
    }
    return localMap;
  }
  
  public static final <T, K, M extends Map<? super K, ? super T>> M associateByTo(Sequence<? extends T> paramSequence, M paramM, Function1<? super T, ? extends K> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramM, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "keySelector");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      paramM.put(paramFunction1.invoke(localObject), localObject);
    }
    return paramM;
  }
  
  public static final <T, K, V, M extends Map<? super K, ? super V>> M associateByTo(Sequence<? extends T> paramSequence, M paramM, Function1<? super T, ? extends K> paramFunction1, Function1<? super T, ? extends V> paramFunction11)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramM, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "keySelector");
    Intrinsics.checkNotNullParameter(paramFunction11, "valueTransform");
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      paramM.put(paramFunction1.invoke(paramSequence), paramFunction11.invoke(paramSequence));
    }
    return paramM;
  }
  
  public static final <T, K, V, M extends Map<? super K, ? super V>> M associateTo(Sequence<? extends T> paramSequence, M paramM, Function1<? super T, ? extends Pair<? extends K, ? extends V>> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramM, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Pair localPair = (Pair)paramFunction1.invoke(paramSequence.next());
      paramM.put(localPair.getFirst(), localPair.getSecond());
    }
    return paramM;
  }
  
  public static final <K, V> Map<K, V> associateWith(Sequence<? extends K> paramSequence, Function1<? super K, ? extends V> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "valueSelector");
    LinkedHashMap localLinkedHashMap = new LinkedHashMap();
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      ((Map)localLinkedHashMap).put(paramSequence, paramFunction1.invoke(paramSequence));
    }
    return (Map)localLinkedHashMap;
  }
  
  public static final <K, V, M extends Map<? super K, ? super V>> M associateWithTo(Sequence<? extends K> paramSequence, M paramM, Function1<? super K, ? extends V> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramM, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "valueSelector");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      paramM.put(localObject, paramFunction1.invoke(localObject));
    }
    return paramM;
  }
  
  public static final double averageOfByte(Sequence<Byte> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    double d1 = 0.0D;
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      double d2 = d1 + ((Number)paramSequence.next()).byteValue();
      int j = i + 1;
      d1 = d2;
      i = j;
      if (j < 0)
      {
        CollectionsKt.throwCountOverflow();
        d1 = d2;
        i = j;
      }
    }
    if (i == 0) {
      d1 = NaN.0D;
    } else {
      d1 /= i;
    }
    return d1;
  }
  
  public static final double averageOfDouble(Sequence<Double> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    double d1 = 0.0D;
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      double d2 = d1 + ((Number)paramSequence.next()).doubleValue();
      int j = i + 1;
      d1 = d2;
      i = j;
      if (j < 0)
      {
        CollectionsKt.throwCountOverflow();
        d1 = d2;
        i = j;
      }
    }
    if (i == 0) {
      d1 = NaN.0D;
    } else {
      d1 /= i;
    }
    return d1;
  }
  
  public static final double averageOfFloat(Sequence<Float> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    double d1 = 0.0D;
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      double d2 = d1 + ((Number)paramSequence.next()).floatValue();
      int j = i + 1;
      d1 = d2;
      i = j;
      if (j < 0)
      {
        CollectionsKt.throwCountOverflow();
        d1 = d2;
        i = j;
      }
    }
    if (i == 0) {
      d1 = NaN.0D;
    } else {
      d1 /= i;
    }
    return d1;
  }
  
  public static final double averageOfInt(Sequence<Integer> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    double d1 = 0.0D;
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      double d2 = d1 + ((Number)paramSequence.next()).intValue();
      int j = i + 1;
      d1 = d2;
      i = j;
      if (j < 0)
      {
        CollectionsKt.throwCountOverflow();
        d1 = d2;
        i = j;
      }
    }
    if (i == 0) {
      d1 = NaN.0D;
    } else {
      d1 /= i;
    }
    return d1;
  }
  
  public static final double averageOfLong(Sequence<Long> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    double d1 = 0.0D;
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      double d2 = d1 + ((Number)paramSequence.next()).longValue();
      int j = i + 1;
      d1 = d2;
      i = j;
      if (j < 0)
      {
        CollectionsKt.throwCountOverflow();
        d1 = d2;
        i = j;
      }
    }
    if (i == 0) {
      d1 = NaN.0D;
    } else {
      d1 /= i;
    }
    return d1;
  }
  
  public static final double averageOfShort(Sequence<Short> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    double d1 = 0.0D;
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      double d2 = d1 + ((Number)paramSequence.next()).shortValue();
      int j = i + 1;
      d1 = d2;
      i = j;
      if (j < 0)
      {
        CollectionsKt.throwCountOverflow();
        d1 = d2;
        i = j;
      }
    }
    if (i == 0) {
      d1 = NaN.0D;
    } else {
      d1 /= i;
    }
    return d1;
  }
  
  public static final <T> Sequence<List<T>> chunked(Sequence<? extends T> paramSequence, int paramInt)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return SequencesKt.windowed(paramSequence, paramInt, paramInt, true);
  }
  
  public static final <T, R> Sequence<R> chunked(Sequence<? extends T> paramSequence, int paramInt, Function1<? super List<? extends T>, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    return SequencesKt.windowed(paramSequence, paramInt, paramInt, true, paramFunction1);
  }
  
  public static final <T> boolean contains(Sequence<? extends T> paramSequence, T paramT)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    boolean bool;
    if (SequencesKt.indexOf(paramSequence, paramT) >= 0) {
      bool = true;
    } else {
      bool = false;
    }
    return bool;
  }
  
  public static final <T> int count(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      paramSequence.next();
      int j = i + 1;
      i = j;
      if (j < 0)
      {
        CollectionsKt.throwCountOverflow();
        i = j;
      }
    }
    return i;
  }
  
  public static final <T> int count(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      if (((Boolean)paramFunction1.invoke(paramSequence.next())).booleanValue())
      {
        int j = i + 1;
        i = j;
        if (j < 0)
        {
          CollectionsKt.throwCountOverflow();
          i = j;
        }
      }
    }
    return i;
  }
  
  public static final <T> Sequence<T> distinct(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return SequencesKt.distinctBy(paramSequence, (Function1)distinct.1.INSTANCE);
  }
  
  public static final <T, K> Sequence<T> distinctBy(Sequence<? extends T> paramSequence, Function1<? super T, ? extends K> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    return (Sequence)new DistinctSequence(paramSequence, paramFunction1);
  }
  
  public static final <T> Sequence<T> drop(Sequence<? extends T> paramSequence, int paramInt)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    int i;
    if (paramInt >= 0) {
      i = 1;
    } else {
      i = 0;
    }
    if (i != 0)
    {
      if (paramInt != 0) {
        if ((paramSequence instanceof DropTakeSequence)) {
          paramSequence = ((DropTakeSequence)paramSequence).drop(paramInt);
        } else {
          paramSequence = (Sequence)new DropSequence(paramSequence, paramInt);
        }
      }
      return paramSequence;
    }
    throw new IllegalArgumentException(("Requested element count " + paramInt + " is less than zero.").toString());
  }
  
  public static final <T> Sequence<T> dropWhile(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    return (Sequence)new DropWhileSequence(paramSequence, paramFunction1);
  }
  
  public static final <T> T elementAt(Sequence<? extends T> paramSequence, int paramInt)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    (T)SequencesKt.elementAtOrElse(paramSequence, paramInt, (Function1)new Lambda(paramInt)
    {
      final int $index;
      
      public final T invoke(int paramAnonymousInt)
      {
        throw new IndexOutOfBoundsException("Sequence doesn't contain element at index " + this.$index + '.');
      }
    });
  }
  
  public static final <T> T elementAtOrElse(Sequence<? extends T> paramSequence, int paramInt, Function1<? super Integer, ? extends T> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "defaultValue");
    if (paramInt < 0) {
      return (T)paramFunction1.invoke(Integer.valueOf(paramInt));
    }
    Iterator localIterator = paramSequence.iterator();
    for (int i = 0; localIterator.hasNext(); i++)
    {
      paramSequence = localIterator.next();
      if (paramInt == i) {
        return paramSequence;
      }
    }
    return (T)paramFunction1.invoke(Integer.valueOf(paramInt));
  }
  
  public static final <T> T elementAtOrNull(Sequence<? extends T> paramSequence, int paramInt)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    if (paramInt < 0) {
      return null;
    }
    Iterator localIterator = paramSequence.iterator();
    for (int i = 0; localIterator.hasNext(); i++)
    {
      paramSequence = localIterator.next();
      if (paramInt == i) {
        return paramSequence;
      }
    }
    return null;
  }
  
  public static final <T> Sequence<T> filter(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    return (Sequence)new FilteringSequence(paramSequence, true, paramFunction1);
  }
  
  public static final <T> Sequence<T> filterIndexed(Sequence<? extends T> paramSequence, Function2<? super Integer, ? super T, Boolean> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "predicate");
    (Sequence)new TransformingSequence((Sequence)new FilteringSequence((Sequence)new IndexingSequence(paramSequence), true, (Function1)new Lambda(paramFunction2)
    {
      final Function2<Integer, T, Boolean> $predicate;
      
      public final Boolean invoke(IndexedValue<? extends T> paramAnonymousIndexedValue)
      {
        Intrinsics.checkNotNullParameter(paramAnonymousIndexedValue, "it");
        return (Boolean)this.$predicate.invoke(Integer.valueOf(paramAnonymousIndexedValue.getIndex()), paramAnonymousIndexedValue.getValue());
      }
    }), (Function1)filterIndexed.2.INSTANCE);
  }
  
  public static final <T, C extends Collection<? super T>> C filterIndexedTo(Sequence<? extends T> paramSequence, C paramC, Function2<? super Integer, ? super T, Boolean> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction2, "predicate");
    int i = 0;
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      if (((Boolean)paramFunction2.invoke(Integer.valueOf(i), paramSequence)).booleanValue()) {
        paramC.add(paramSequence);
      }
      i++;
    }
    return paramC;
  }
  
  public static final <T> Sequence<T> filterNot(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    return (Sequence)new FilteringSequence(paramSequence, false, paramFunction1);
  }
  
  public static final <T> Sequence<T> filterNotNull(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = SequencesKt.filterNot(paramSequence, (Function1)filterNotNull.1.INSTANCE);
    Intrinsics.checkNotNull(paramSequence, "null cannot be cast to non-null type kotlin.sequences.Sequence<T of kotlin.sequences.SequencesKt___SequencesKt.filterNotNull>");
    return paramSequence;
  }
  
  public static final <C extends Collection<? super T>, T> C filterNotNullTo(Sequence<? extends T> paramSequence, C paramC)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      if (localObject != null) {
        paramC.add(localObject);
      }
    }
    return paramC;
  }
  
  public static final <T, C extends Collection<? super T>> C filterNotTo(Sequence<? extends T> paramSequence, C paramC, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      if (!((Boolean)paramFunction1.invoke(paramSequence)).booleanValue()) {
        paramC.add(paramSequence);
      }
    }
    return paramC;
  }
  
  public static final <T, C extends Collection<? super T>> C filterTo(Sequence<? extends T> paramSequence, C paramC, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      if (((Boolean)paramFunction1.invoke(paramSequence)).booleanValue()) {
        paramC.add(paramSequence);
      }
    }
    return paramC;
  }
  
  private static final <T> T find(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      if (((Boolean)paramFunction1.invoke(paramSequence)).booleanValue()) {
        return paramSequence;
      }
    }
    paramSequence = null;
    return paramSequence;
  }
  
  private static final <T> T findLast(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    Object localObject = null;
    Iterator localIterator = paramSequence.iterator();
    paramSequence = (Sequence<? extends T>)localObject;
    while (localIterator.hasNext())
    {
      localObject = localIterator.next();
      if (((Boolean)paramFunction1.invoke(localObject)).booleanValue()) {
        paramSequence = (Sequence<? extends T>)localObject;
      }
    }
    return paramSequence;
  }
  
  public static final <T> T first(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext()) {
      return (T)paramSequence.next();
    }
    throw new NoSuchElementException("Sequence is empty.");
  }
  
  public static final <T> T first(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      if (((Boolean)paramFunction1.invoke(paramSequence)).booleanValue()) {
        return paramSequence;
      }
    }
    throw new NoSuchElementException("Sequence contains no element matching the predicate.");
  }
  
  private static final <T, R> R firstNotNullOf(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      Object localObject = paramFunction1.invoke(localIterator.next());
      paramSequence = (Sequence<? extends T>)localObject;
      if (localObject != null) {
        break label54;
      }
    }
    paramSequence = null;
    label54:
    if (paramSequence != null) {
      return paramSequence;
    }
    throw new NoSuchElementException("No element of the sequence was transformed to a non-null value.");
  }
  
  private static final <T, R> R firstNotNullOfOrNull(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = paramFunction1.invoke(localIterator.next());
      if (paramSequence != null) {
        return paramSequence;
      }
    }
    return null;
  }
  
  public static final <T> T firstOrNull(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (!paramSequence.hasNext()) {
      return null;
    }
    return (T)paramSequence.next();
  }
  
  public static final <T> T firstOrNull(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      if (((Boolean)paramFunction1.invoke(localObject)).booleanValue()) {
        return (T)localObject;
      }
    }
    return null;
  }
  
  public static final <T, R> Sequence<R> flatMap(Sequence<? extends T> paramSequence, Function1<? super T, ? extends Sequence<? extends R>> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    return (Sequence)new FlatteningSequence(paramSequence, paramFunction1, (Function1)flatMap.2.INSTANCE);
  }
  
  public static final <T, R> Sequence<R> flatMapIndexedIterable(Sequence<? extends T> paramSequence, Function2<? super Integer, ? super T, ? extends Iterable<? extends R>> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    return SequencesKt.flatMapIndexed(paramSequence, paramFunction2, (Function1)flatMapIndexed.1.INSTANCE);
  }
  
  private static final <T, R, C extends Collection<? super R>> C flatMapIndexedIterableTo(Sequence<? extends T> paramSequence, C paramC, Function2<? super Integer, ? super T, ? extends Iterable<? extends R>> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      CollectionsKt.addAll(paramC, (Iterable)paramFunction2.invoke(Integer.valueOf(i), localObject));
      i++;
    }
    return paramC;
  }
  
  public static final <T, R> Sequence<R> flatMapIndexedSequence(Sequence<? extends T> paramSequence, Function2<? super Integer, ? super T, ? extends Sequence<? extends R>> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    return SequencesKt.flatMapIndexed(paramSequence, paramFunction2, (Function1)flatMapIndexed.2.INSTANCE);
  }
  
  private static final <T, R, C extends Collection<? super R>> C flatMapIndexedSequenceTo(Sequence<? extends T> paramSequence, C paramC, Function2<? super Integer, ? super T, ? extends Sequence<? extends R>> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      CollectionsKt.addAll(paramC, (Sequence)paramFunction2.invoke(Integer.valueOf(i), localObject));
      i++;
    }
    return paramC;
  }
  
  public static final <T, R> Sequence<R> flatMapIterable(Sequence<? extends T> paramSequence, Function1<? super T, ? extends Iterable<? extends R>> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    return (Sequence)new FlatteningSequence(paramSequence, paramFunction1, (Function1)flatMap.1.INSTANCE);
  }
  
  public static final <T, R, C extends Collection<? super R>> C flatMapIterableTo(Sequence<? extends T> paramSequence, C paramC, Function1<? super T, ? extends Iterable<? extends R>> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      CollectionsKt.addAll(paramC, (Iterable)paramFunction1.invoke(paramSequence.next()));
    }
    return paramC;
  }
  
  public static final <T, R, C extends Collection<? super R>> C flatMapTo(Sequence<? extends T> paramSequence, C paramC, Function1<? super T, ? extends Sequence<? extends R>> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      CollectionsKt.addAll(paramC, (Sequence)paramFunction1.invoke(paramSequence.next()));
    }
    return paramC;
  }
  
  public static final <T, R> R fold(Sequence<? extends T> paramSequence, R paramR, Function2<? super R, ? super T, ? extends R> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "operation");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      paramR = paramFunction2.invoke(paramR, paramSequence.next());
    }
    return paramR;
  }
  
  public static final <T, R> R foldIndexed(Sequence<? extends T> paramSequence, R paramR, Function3<? super Integer, ? super R, ? super T, ? extends R> paramFunction3)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction3, "operation");
    int i = 0;
    Iterator localIterator = paramSequence.iterator();
    paramSequence = paramR;
    while (localIterator.hasNext())
    {
      paramR = localIterator.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      paramSequence = paramFunction3.invoke(Integer.valueOf(i), paramSequence, paramR);
      i++;
    }
    return paramSequence;
  }
  
  public static final <T> void forEach(Sequence<? extends T> paramSequence, Function1<? super T, Unit> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "action");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      paramFunction1.invoke(paramSequence.next());
    }
  }
  
  public static final <T> void forEachIndexed(Sequence<? extends T> paramSequence, Function2<? super Integer, ? super T, Unit> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "action");
    int i = 0;
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      paramFunction2.invoke(Integer.valueOf(i), paramSequence);
      i++;
    }
  }
  
  public static final <T, K> Map<K, List<T>> groupBy(Sequence<? extends T> paramSequence, Function1<? super T, ? extends K> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "keySelector");
    Map localMap = (Map)new LinkedHashMap();
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      Object localObject1 = localIterator.next();
      Object localObject2 = paramFunction1.invoke(localObject1);
      paramSequence = localMap.get(localObject2);
      if (paramSequence == null)
      {
        paramSequence = (List)new ArrayList();
        localMap.put(localObject2, paramSequence);
      }
      ((List)paramSequence).add(localObject1);
    }
    return localMap;
  }
  
  public static final <T, K, V> Map<K, List<V>> groupBy(Sequence<? extends T> paramSequence, Function1<? super T, ? extends K> paramFunction1, Function1<? super T, ? extends V> paramFunction11)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "keySelector");
    Intrinsics.checkNotNullParameter(paramFunction11, "valueTransform");
    Map localMap = (Map)new LinkedHashMap();
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      Object localObject1 = localIterator.next();
      Object localObject2 = paramFunction1.invoke(localObject1);
      paramSequence = localMap.get(localObject2);
      if (paramSequence == null)
      {
        paramSequence = (List)new ArrayList();
        localMap.put(localObject2, paramSequence);
      }
      ((List)paramSequence).add(paramFunction11.invoke(localObject1));
    }
    return localMap;
  }
  
  public static final <T, K, M extends Map<? super K, List<T>>> M groupByTo(Sequence<? extends T> paramSequence, M paramM, Function1<? super T, ? extends K> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramM, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "keySelector");
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      Object localObject1 = localIterator.next();
      Object localObject2 = paramFunction1.invoke(localObject1);
      paramSequence = paramM.get(localObject2);
      if (paramSequence == null)
      {
        paramSequence = (List)new ArrayList();
        paramM.put(localObject2, paramSequence);
      }
      ((List)paramSequence).add(localObject1);
    }
    return paramM;
  }
  
  public static final <T, K, V, M extends Map<? super K, List<V>>> M groupByTo(Sequence<? extends T> paramSequence, M paramM, Function1<? super T, ? extends K> paramFunction1, Function1<? super T, ? extends V> paramFunction11)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramM, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "keySelector");
    Intrinsics.checkNotNullParameter(paramFunction11, "valueTransform");
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      Object localObject1 = localIterator.next();
      Object localObject2 = paramFunction1.invoke(localObject1);
      paramSequence = paramM.get(localObject2);
      if (paramSequence == null)
      {
        paramSequence = (List)new ArrayList();
        paramM.put(localObject2, paramSequence);
      }
      ((List)paramSequence).add(paramFunction11.invoke(localObject1));
    }
    return paramM;
  }
  
  public static final <T, K> Grouping<T, K> groupingBy(Sequence<? extends T> paramSequence, final Function1<? super T, ? extends K> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "keySelector");
    (Grouping)new Grouping()
    {
      final Sequence<T> $this_groupingBy;
      
      public K keyOf(T paramAnonymousT)
      {
        return (K)paramFunction1.invoke(paramAnonymousT);
      }
      
      public Iterator<T> sourceIterator()
      {
        return this.$this_groupingBy.iterator();
      }
    };
  }
  
  public static final <T> int indexOf(Sequence<? extends T> paramSequence, T paramT)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      if (Intrinsics.areEqual(paramT, localObject)) {
        return i;
      }
      i++;
    }
    return -1;
  }
  
  public static final <T> int indexOfFirst(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    int i = 0;
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      if (((Boolean)paramFunction1.invoke(paramSequence)).booleanValue()) {
        return i;
      }
      i++;
    }
    return -1;
  }
  
  public static final <T> int indexOfLast(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    int j = -1;
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      if (((Boolean)paramFunction1.invoke(localObject)).booleanValue()) {
        j = i;
      }
      i++;
    }
    return j;
  }
  
  public static final <T, A extends Appendable> A joinTo(Sequence<? extends T> paramSequence, A paramA, CharSequence paramCharSequence1, CharSequence paramCharSequence2, CharSequence paramCharSequence3, int paramInt, CharSequence paramCharSequence4, Function1<? super T, ? extends CharSequence> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramA, "buffer");
    Intrinsics.checkNotNullParameter(paramCharSequence1, "separator");
    Intrinsics.checkNotNullParameter(paramCharSequence2, "prefix");
    Intrinsics.checkNotNullParameter(paramCharSequence3, "postfix");
    Intrinsics.checkNotNullParameter(paramCharSequence4, "truncated");
    paramA.append(paramCharSequence2);
    int i = 0;
    paramCharSequence2 = paramSequence.iterator();
    int j;
    for (;;)
    {
      j = i;
      if (!paramCharSequence2.hasNext()) {
        break;
      }
      paramSequence = paramCharSequence2.next();
      i++;
      if (i > 1) {
        paramA.append(paramCharSequence1);
      }
      if ((paramInt >= 0) && (i > paramInt))
      {
        j = i;
        break;
      }
      StringsKt.appendElement(paramA, paramSequence, paramFunction1);
    }
    if ((paramInt >= 0) && (j > paramInt)) {
      paramA.append(paramCharSequence4);
    }
    paramA.append(paramCharSequence3);
    return paramA;
  }
  
  public static final <T> String joinToString(Sequence<? extends T> paramSequence, CharSequence paramCharSequence1, CharSequence paramCharSequence2, CharSequence paramCharSequence3, int paramInt, CharSequence paramCharSequence4, Function1<? super T, ? extends CharSequence> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramCharSequence1, "separator");
    Intrinsics.checkNotNullParameter(paramCharSequence2, "prefix");
    Intrinsics.checkNotNullParameter(paramCharSequence3, "postfix");
    Intrinsics.checkNotNullParameter(paramCharSequence4, "truncated");
    paramSequence = ((StringBuilder)SequencesKt.joinTo(paramSequence, (Appendable)new StringBuilder(), paramCharSequence1, paramCharSequence2, paramCharSequence3, paramInt, paramCharSequence4, paramFunction1)).toString();
    Intrinsics.checkNotNullExpressionValue(paramSequence, "joinTo(StringBuilder(), …ed, transform).toString()");
    return paramSequence;
  }
  
  public static final <T> T last(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      for (paramSequence = localIterator.next(); localIterator.hasNext(); paramSequence = localIterator.next()) {}
      return paramSequence;
    }
    throw new NoSuchElementException("Sequence is empty.");
  }
  
  public static final <T> T last(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    Object localObject = null;
    int i = 0;
    Iterator localIterator = paramSequence.iterator();
    paramSequence = (Sequence<? extends T>)localObject;
    while (localIterator.hasNext())
    {
      localObject = localIterator.next();
      if (((Boolean)paramFunction1.invoke(localObject)).booleanValue())
      {
        paramSequence = (Sequence<? extends T>)localObject;
        i = 1;
      }
    }
    if (i != 0) {
      return paramSequence;
    }
    throw new NoSuchElementException("Sequence contains no element matching the predicate.");
  }
  
  public static final <T> int lastIndexOf(Sequence<? extends T> paramSequence, T paramT)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    int j = -1;
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      if (Intrinsics.areEqual(paramT, localObject)) {
        j = i;
      }
      i++;
    }
    return j;
  }
  
  public static final <T> T lastOrNull(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    for (paramSequence = localIterator.next(); localIterator.hasNext(); paramSequence = localIterator.next()) {}
    return paramSequence;
  }
  
  public static final <T> T lastOrNull(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    Object localObject = null;
    Iterator localIterator = paramSequence.iterator();
    paramSequence = (Sequence<? extends T>)localObject;
    while (localIterator.hasNext())
    {
      localObject = localIterator.next();
      if (((Boolean)paramFunction1.invoke(localObject)).booleanValue()) {
        paramSequence = (Sequence<? extends T>)localObject;
      }
    }
    return paramSequence;
  }
  
  public static final <T, R> Sequence<R> map(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    return (Sequence)new TransformingSequence(paramSequence, paramFunction1);
  }
  
  public static final <T, R> Sequence<R> mapIndexed(Sequence<? extends T> paramSequence, Function2<? super Integer, ? super T, ? extends R> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    return (Sequence)new TransformingIndexedSequence(paramSequence, paramFunction2);
  }
  
  public static final <T, R> Sequence<R> mapIndexedNotNull(Sequence<? extends T> paramSequence, Function2<? super Integer, ? super T, ? extends R> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    return SequencesKt.filterNotNull((Sequence)new TransformingIndexedSequence(paramSequence, paramFunction2));
  }
  
  public static final <T, R, C extends Collection<? super R>> C mapIndexedNotNullTo(Sequence<? extends T> paramSequence, C paramC, Function2<? super Integer, ? super T, ? extends R> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      localObject = paramFunction2.invoke(Integer.valueOf(i), localObject);
      if (localObject != null) {
        paramC.add(localObject);
      }
      i++;
    }
    return paramC;
  }
  
  public static final <T, R, C extends Collection<? super R>> C mapIndexedTo(Sequence<? extends T> paramSequence, C paramC, Function2<? super Integer, ? super T, ? extends R> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    int i = 0;
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      paramC.add(paramFunction2.invoke(Integer.valueOf(i), paramSequence));
      i++;
    }
    return paramC;
  }
  
  public static final <T, R> Sequence<R> mapNotNull(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    return SequencesKt.filterNotNull((Sequence)new TransformingSequence(paramSequence, paramFunction1));
  }
  
  public static final <T, R, C extends Collection<? super R>> C mapNotNullTo(Sequence<? extends T> paramSequence, C paramC, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext())
    {
      Object localObject = paramFunction1.invoke(paramSequence.next());
      if (localObject != null) {
        paramC.add(localObject);
      }
    }
    return paramC;
  }
  
  public static final <T, R, C extends Collection<? super R>> C mapTo(Sequence<? extends T> paramSequence, C paramC, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      paramC.add(paramFunction1.invoke(paramSequence.next()));
    }
    return paramC;
  }
  
  public static final <T, R extends Comparable<? super R>> T maxByOrNull(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    Object localObject2 = localIterator.next();
    if (!localIterator.hasNext()) {
      return (T)localObject2;
    }
    paramSequence = (Comparable)paramFunction1.invoke(localObject2);
    Object localObject3;
    do
    {
      Object localObject4 = localIterator.next();
      Comparable localComparable = (Comparable)paramFunction1.invoke(localObject4);
      localObject3 = localObject2;
      Object localObject1 = paramSequence;
      if (paramSequence.compareTo(localComparable) < 0)
      {
        localObject3 = localObject4;
        localObject1 = localComparable;
      }
      localObject2 = localObject3;
      paramSequence = (Sequence<? extends T>)localObject1;
    } while (localIterator.hasNext());
    return (T)localObject3;
  }
  
  public static final <T, R extends Comparable<? super R>> T maxByOrThrow(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      Object localObject3 = localIterator.next();
      if (!localIterator.hasNext()) {
        return (T)localObject3;
      }
      Object localObject1 = (Comparable)paramFunction1.invoke(localObject3);
      Object localObject2;
      do
      {
        Object localObject4 = localIterator.next();
        Comparable localComparable = (Comparable)paramFunction1.invoke(localObject4);
        localObject2 = localObject3;
        paramSequence = (Sequence<? extends T>)localObject1;
        if (((Comparable)localObject1).compareTo(localComparable) < 0)
        {
          localObject2 = localObject4;
          paramSequence = localComparable;
        }
        localObject3 = localObject2;
        localObject1 = paramSequence;
      } while (localIterator.hasNext());
      return (T)localObject2;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T> double maxOf(Sequence<? extends T> paramSequence, Function1<? super T, Double> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext())
    {
      for (double d = ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue(); paramSequence.hasNext(); d = Math.max(d, ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue())) {}
      return d;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T> float maxOf(Sequence<? extends T> paramSequence, Function1<? super T, Float> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext())
    {
      for (float f = ((Number)paramFunction1.invoke(paramSequence.next())).floatValue(); paramSequence.hasNext(); f = Math.max(f, ((Number)paramFunction1.invoke(paramSequence.next())).floatValue())) {}
      return f;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T, R extends Comparable<? super R>> R maxOf(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      paramSequence = (Comparable)paramFunction1.invoke(localIterator.next());
      while (localIterator.hasNext())
      {
        Comparable localComparable = (Comparable)paramFunction1.invoke(localIterator.next());
        if (paramSequence.compareTo(localComparable) < 0) {
          paramSequence = localComparable;
        }
      }
      return paramSequence;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T, R extends Comparable<? super R>> R maxOfOrNull(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    paramSequence = (Comparable)paramFunction1.invoke(localIterator.next());
    while (localIterator.hasNext())
    {
      Comparable localComparable = (Comparable)paramFunction1.invoke(localIterator.next());
      if (paramSequence.compareTo(localComparable) < 0) {
        paramSequence = localComparable;
      }
    }
    return paramSequence;
  }
  
  private static final <T> Double maxOfOrNull(Sequence<? extends T> paramSequence, Function1<? super T, Double> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    paramSequence = paramSequence.iterator();
    if (!paramSequence.hasNext()) {
      return null;
    }
    for (double d = ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue(); paramSequence.hasNext(); d = Math.max(d, ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue())) {}
    return Double.valueOf(d);
  }
  
  private static final <T> Float maxOfOrNull(Sequence<? extends T> paramSequence, Function1<? super T, Float> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    paramSequence = paramSequence.iterator();
    if (!paramSequence.hasNext()) {
      return null;
    }
    for (float f = ((Number)paramFunction1.invoke(paramSequence.next())).floatValue(); paramSequence.hasNext(); f = Math.max(f, ((Number)paramFunction1.invoke(paramSequence.next())).floatValue())) {}
    return Float.valueOf(f);
  }
  
  private static final <T, R> R maxOfWith(Sequence<? extends T> paramSequence, Comparator<? super R> paramComparator, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramComparator, "comparator");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      paramSequence = paramFunction1.invoke(localIterator.next());
      while (localIterator.hasNext())
      {
        Object localObject = paramFunction1.invoke(localIterator.next());
        if (paramComparator.compare(paramSequence, localObject) < 0) {
          paramSequence = (Sequence<? extends T>)localObject;
        }
      }
      return paramSequence;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T, R> R maxOfWithOrNull(Sequence<? extends T> paramSequence, Comparator<? super R> paramComparator, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramComparator, "comparator");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    paramSequence = paramFunction1.invoke(localIterator.next());
    while (localIterator.hasNext())
    {
      Object localObject = paramFunction1.invoke(localIterator.next());
      if (paramComparator.compare(paramSequence, localObject) < 0) {
        paramSequence = (Sequence<? extends T>)localObject;
      }
    }
    return paramSequence;
  }
  
  public static final <T extends Comparable<? super T>> T maxOrNull(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    paramSequence = (Comparable)localIterator.next();
    while (localIterator.hasNext())
    {
      Comparable localComparable = (Comparable)localIterator.next();
      if (paramSequence.compareTo(localComparable) < 0) {
        paramSequence = localComparable;
      }
    }
    return paramSequence;
  }
  
  public static final Double maxOrNull(Sequence<Double> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (!paramSequence.hasNext()) {
      return null;
    }
    for (double d = ((Number)paramSequence.next()).doubleValue(); paramSequence.hasNext(); d = Math.max(d, ((Number)paramSequence.next()).doubleValue())) {}
    return Double.valueOf(d);
  }
  
  public static final Float maxOrNull(Sequence<Float> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (!paramSequence.hasNext()) {
      return null;
    }
    for (float f = ((Number)paramSequence.next()).floatValue(); paramSequence.hasNext(); f = Math.max(f, ((Number)paramSequence.next()).floatValue())) {}
    return Float.valueOf(f);
  }
  
  public static final double maxOrThrow(Sequence<Double> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext())
    {
      for (double d = ((Number)paramSequence.next()).doubleValue(); paramSequence.hasNext(); d = Math.max(d, ((Number)paramSequence.next()).doubleValue())) {}
      return d;
    }
    throw new NoSuchElementException();
  }
  
  public static final float maxOrThrow(Sequence<Float> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext())
    {
      for (float f = ((Number)paramSequence.next()).floatValue(); paramSequence.hasNext(); f = Math.max(f, ((Number)paramSequence.next()).floatValue())) {}
      return f;
    }
    throw new NoSuchElementException();
  }
  
  public static final <T extends Comparable<? super T>> T maxOrThrow(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      paramSequence = (Comparable)localIterator.next();
      while (localIterator.hasNext())
      {
        Comparable localComparable = (Comparable)localIterator.next();
        if (paramSequence.compareTo(localComparable) < 0) {
          paramSequence = localComparable;
        }
      }
      return paramSequence;
    }
    throw new NoSuchElementException();
  }
  
  public static final <T> T maxWithOrNull(Sequence<? extends T> paramSequence, Comparator<? super T> paramComparator)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramComparator, "comparator");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    paramSequence = localIterator.next();
    while (localIterator.hasNext())
    {
      Object localObject = localIterator.next();
      if (paramComparator.compare(paramSequence, localObject) < 0) {
        paramSequence = (Sequence<? extends T>)localObject;
      }
    }
    return paramSequence;
  }
  
  public static final <T> T maxWithOrThrow(Sequence<? extends T> paramSequence, Comparator<? super T> paramComparator)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramComparator, "comparator");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      while (localIterator.hasNext())
      {
        Object localObject = localIterator.next();
        if (paramComparator.compare(paramSequence, localObject) < 0) {
          paramSequence = (Sequence<? extends T>)localObject;
        }
      }
      return paramSequence;
    }
    throw new NoSuchElementException();
  }
  
  public static final <T, R extends Comparable<? super R>> T minByOrNull(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    Object localObject2 = localIterator.next();
    if (!localIterator.hasNext()) {
      return (T)localObject2;
    }
    Object localObject1 = (Comparable)paramFunction1.invoke(localObject2);
    Object localObject3;
    do
    {
      Object localObject4 = localIterator.next();
      Comparable localComparable = (Comparable)paramFunction1.invoke(localObject4);
      localObject3 = localObject2;
      paramSequence = (Sequence<? extends T>)localObject1;
      if (((Comparable)localObject1).compareTo(localComparable) > 0)
      {
        localObject3 = localObject4;
        paramSequence = localComparable;
      }
      localObject2 = localObject3;
      localObject1 = paramSequence;
    } while (localIterator.hasNext());
    return (T)localObject3;
  }
  
  public static final <T, R extends Comparable<? super R>> T minByOrThrow(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      Object localObject3 = localIterator.next();
      if (!localIterator.hasNext()) {
        return (T)localObject3;
      }
      paramSequence = (Comparable)paramFunction1.invoke(localObject3);
      Object localObject2;
      do
      {
        Object localObject4 = localIterator.next();
        Comparable localComparable = (Comparable)paramFunction1.invoke(localObject4);
        localObject2 = localObject3;
        Object localObject1 = paramSequence;
        if (paramSequence.compareTo(localComparable) > 0)
        {
          localObject2 = localObject4;
          localObject1 = localComparable;
        }
        localObject3 = localObject2;
        paramSequence = (Sequence<? extends T>)localObject1;
      } while (localIterator.hasNext());
      return (T)localObject2;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T> double minOf(Sequence<? extends T> paramSequence, Function1<? super T, Double> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext())
    {
      for (double d = ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue(); paramSequence.hasNext(); d = Math.min(d, ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue())) {}
      return d;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T> float minOf(Sequence<? extends T> paramSequence, Function1<? super T, Float> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext())
    {
      for (float f = ((Number)paramFunction1.invoke(paramSequence.next())).floatValue(); paramSequence.hasNext(); f = Math.min(f, ((Number)paramFunction1.invoke(paramSequence.next())).floatValue())) {}
      return f;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T, R extends Comparable<? super R>> R minOf(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      paramSequence = (Comparable)paramFunction1.invoke(localIterator.next());
      while (localIterator.hasNext())
      {
        Comparable localComparable = (Comparable)paramFunction1.invoke(localIterator.next());
        if (paramSequence.compareTo(localComparable) > 0) {
          paramSequence = localComparable;
        }
      }
      return paramSequence;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T, R extends Comparable<? super R>> R minOfOrNull(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    paramSequence = (Comparable)paramFunction1.invoke(localIterator.next());
    while (localIterator.hasNext())
    {
      Comparable localComparable = (Comparable)paramFunction1.invoke(localIterator.next());
      if (paramSequence.compareTo(localComparable) > 0) {
        paramSequence = localComparable;
      }
    }
    return paramSequence;
  }
  
  private static final <T> Double minOfOrNull(Sequence<? extends T> paramSequence, Function1<? super T, Double> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    paramSequence = paramSequence.iterator();
    if (!paramSequence.hasNext()) {
      return null;
    }
    for (double d = ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue(); paramSequence.hasNext(); d = Math.min(d, ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue())) {}
    return Double.valueOf(d);
  }
  
  private static final <T> Float minOfOrNull(Sequence<? extends T> paramSequence, Function1<? super T, Float> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    paramSequence = paramSequence.iterator();
    if (!paramSequence.hasNext()) {
      return null;
    }
    for (float f = ((Number)paramFunction1.invoke(paramSequence.next())).floatValue(); paramSequence.hasNext(); f = Math.min(f, ((Number)paramFunction1.invoke(paramSequence.next())).floatValue())) {}
    return Float.valueOf(f);
  }
  
  private static final <T, R> R minOfWith(Sequence<? extends T> paramSequence, Comparator<? super R> paramComparator, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramComparator, "comparator");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      paramSequence = paramFunction1.invoke(localIterator.next());
      while (localIterator.hasNext())
      {
        Object localObject = paramFunction1.invoke(localIterator.next());
        if (paramComparator.compare(paramSequence, localObject) > 0) {
          paramSequence = (Sequence<? extends T>)localObject;
        }
      }
      return paramSequence;
    }
    throw new NoSuchElementException();
  }
  
  private static final <T, R> R minOfWithOrNull(Sequence<? extends T> paramSequence, Comparator<? super R> paramComparator, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramComparator, "comparator");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    paramSequence = paramFunction1.invoke(localIterator.next());
    while (localIterator.hasNext())
    {
      Object localObject = paramFunction1.invoke(localIterator.next());
      if (paramComparator.compare(paramSequence, localObject) > 0) {
        paramSequence = (Sequence<? extends T>)localObject;
      }
    }
    return paramSequence;
  }
  
  public static final <T extends Comparable<? super T>> T minOrNull(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    paramSequence = (Comparable)localIterator.next();
    while (localIterator.hasNext())
    {
      Comparable localComparable = (Comparable)localIterator.next();
      if (paramSequence.compareTo(localComparable) > 0) {
        paramSequence = localComparable;
      }
    }
    return paramSequence;
  }
  
  public static final Double minOrNull(Sequence<Double> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (!paramSequence.hasNext()) {
      return null;
    }
    for (double d = ((Number)paramSequence.next()).doubleValue(); paramSequence.hasNext(); d = Math.min(d, ((Number)paramSequence.next()).doubleValue())) {}
    return Double.valueOf(d);
  }
  
  public static final Float minOrNull(Sequence<Float> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (!paramSequence.hasNext()) {
      return null;
    }
    for (float f = ((Number)paramSequence.next()).floatValue(); paramSequence.hasNext(); f = Math.min(f, ((Number)paramSequence.next()).floatValue())) {}
    return Float.valueOf(f);
  }
  
  public static final double minOrThrow(Sequence<Double> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext())
    {
      for (double d = ((Number)paramSequence.next()).doubleValue(); paramSequence.hasNext(); d = Math.min(d, ((Number)paramSequence.next()).doubleValue())) {}
      return d;
    }
    throw new NoSuchElementException();
  }
  
  public static final float minOrThrow(Sequence<Float> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext())
    {
      for (float f = ((Number)paramSequence.next()).floatValue(); paramSequence.hasNext(); f = Math.min(f, ((Number)paramSequence.next()).floatValue())) {}
      return f;
    }
    throw new NoSuchElementException();
  }
  
  public static final <T extends Comparable<? super T>> T minOrThrow(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      paramSequence = (Comparable)localIterator.next();
      while (localIterator.hasNext())
      {
        Comparable localComparable = (Comparable)localIterator.next();
        if (paramSequence.compareTo(localComparable) > 0) {
          paramSequence = localComparable;
        }
      }
      return paramSequence;
    }
    throw new NoSuchElementException();
  }
  
  public static final <T> T minWithOrNull(Sequence<? extends T> paramSequence, Comparator<? super T> paramComparator)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramComparator, "comparator");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    paramSequence = localIterator.next();
    while (localIterator.hasNext())
    {
      Object localObject = localIterator.next();
      if (paramComparator.compare(paramSequence, localObject) > 0) {
        paramSequence = (Sequence<? extends T>)localObject;
      }
    }
    return paramSequence;
  }
  
  public static final <T> T minWithOrThrow(Sequence<? extends T> paramSequence, Comparator<? super T> paramComparator)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramComparator, "comparator");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      while (localIterator.hasNext())
      {
        Object localObject = localIterator.next();
        if (paramComparator.compare(paramSequence, localObject) > 0) {
          paramSequence = (Sequence<? extends T>)localObject;
        }
      }
      return paramSequence;
    }
    throw new NoSuchElementException();
  }
  
  public static final <T> Sequence<T> minus(final Sequence<? extends T> paramSequence, Iterable<? extends T> paramIterable)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramIterable, "elements");
    (Sequence)new Sequence()
    {
      final Iterable<T> $elements;
      
      public Iterator<T> iterator()
      {
        Collection localCollection = BrittleContainsOptimizationKt.convertToSetForSetOperation(this.$elements);
        if (localCollection.isEmpty()) {
          return paramSequence.iterator();
        }
        SequencesKt.filterNot(paramSequence, (Function1)new Lambda(localCollection)
        {
          final Collection<T> $other;
          
          public final Boolean invoke(T paramAnonymous2T)
          {
            return Boolean.valueOf(this.$other.contains(paramAnonymous2T));
          }
        }).iterator();
      }
    };
  }
  
  public static final <T> Sequence<T> minus(Sequence<? extends T> paramSequence, final T paramT)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    (Sequence)new Sequence()
    {
      final Sequence<T> $this_minus;
      
      public Iterator<T> iterator()
      {
        Ref.BooleanRef localBooleanRef = new Ref.BooleanRef();
        SequencesKt.filter(this.$this_minus, (Function1)new Lambda(localBooleanRef)
        {
          final Ref.BooleanRef $removed;
          
          public final Boolean invoke(T paramAnonymous2T)
          {
            boolean bool3 = this.$removed.element;
            boolean bool2 = true;
            boolean bool1 = bool2;
            if (!bool3)
            {
              bool1 = bool2;
              if (Intrinsics.areEqual(paramAnonymous2T, this.$element))
              {
                this.$removed.element = true;
                bool1 = false;
              }
            }
            return Boolean.valueOf(bool1);
          }
        }).iterator();
      }
    };
  }
  
  public static final <T> Sequence<T> minus(final Sequence<? extends T> paramSequence1, Sequence<? extends T> paramSequence2)
  {
    Intrinsics.checkNotNullParameter(paramSequence1, "<this>");
    Intrinsics.checkNotNullParameter(paramSequence2, "elements");
    (Sequence)new Sequence()
    {
      final Sequence<T> $elements;
      
      public Iterator<T> iterator()
      {
        Collection localCollection = BrittleContainsOptimizationKt.convertToSetForSetOperation(this.$elements);
        if (localCollection.isEmpty()) {
          return paramSequence1.iterator();
        }
        SequencesKt.filterNot(paramSequence1, (Function1)new Lambda(localCollection)
        {
          final Collection<T> $other;
          
          public final Boolean invoke(T paramAnonymous2T)
          {
            return Boolean.valueOf(this.$other.contains(paramAnonymous2T));
          }
        }).iterator();
      }
    };
  }
  
  public static final <T> Sequence<T> minus(final Sequence<? extends T> paramSequence, T[] paramArrayOfT)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramArrayOfT, "elements");
    int i;
    if (paramArrayOfT.length == 0) {
      i = 1;
    } else {
      i = 0;
    }
    if (i != 0) {
      return paramSequence;
    }
    (Sequence)new Sequence()
    {
      final T[] $elements;
      
      public Iterator<T> iterator()
      {
        Collection localCollection = BrittleContainsOptimizationKt.convertToSetForSetOperation(this.$elements);
        SequencesKt.filterNot(paramSequence, (Function1)new Lambda(localCollection)
        {
          final Collection<T> $other;
          
          public final Boolean invoke(T paramAnonymous2T)
          {
            return Boolean.valueOf(this.$other.contains(paramAnonymous2T));
          }
        }).iterator();
      }
    };
  }
  
  private static final <T> Sequence<T> minusElement(Sequence<? extends T> paramSequence, T paramT)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return SequencesKt.minus(paramSequence, paramT);
  }
  
  public static final <T> boolean none(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return paramSequence.iterator().hasNext() ^ true;
  }
  
  public static final <T> boolean none(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      if (((Boolean)paramFunction1.invoke(paramSequence.next())).booleanValue()) {
        return false;
      }
    }
    return true;
  }
  
  public static final <T> Sequence<T> onEach(Sequence<? extends T> paramSequence, Function1<? super T, Unit> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "action");
    SequencesKt.map(paramSequence, (Function1)new Lambda(paramFunction1)
    {
      final Function1<T, Unit> $action;
      
      public final T invoke(T paramAnonymousT)
      {
        this.$action.invoke(paramAnonymousT);
        return paramAnonymousT;
      }
    });
  }
  
  public static final <T> Sequence<T> onEachIndexed(Sequence<? extends T> paramSequence, Function2<? super Integer, ? super T, Unit> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "action");
    SequencesKt.mapIndexed(paramSequence, (Function2)new Lambda(paramFunction2)
    {
      final Function2<Integer, T, Unit> $action;
      
      public final T invoke(int paramAnonymousInt, T paramAnonymousT)
      {
        this.$action.invoke(Integer.valueOf(paramAnonymousInt), paramAnonymousT);
        return paramAnonymousT;
      }
    });
  }
  
  public static final <T> Pair<List<T>, List<T>> partition(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    ArrayList localArrayList1 = new ArrayList();
    ArrayList localArrayList2 = new ArrayList();
    Iterator localIterator = paramSequence.iterator();
    while (localIterator.hasNext())
    {
      paramSequence = localIterator.next();
      if (((Boolean)paramFunction1.invoke(paramSequence)).booleanValue()) {
        localArrayList1.add(paramSequence);
      } else {
        localArrayList2.add(paramSequence);
      }
    }
    return new Pair(localArrayList1, localArrayList2);
  }
  
  public static final <T> Sequence<T> plus(Sequence<? extends T> paramSequence, Iterable<? extends T> paramIterable)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramIterable, "elements");
    return SequencesKt.flatten(SequencesKt.sequenceOf(new Sequence[] { paramSequence, CollectionsKt.asSequence(paramIterable) }));
  }
  
  public static final <T> Sequence<T> plus(Sequence<? extends T> paramSequence, T paramT)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return SequencesKt.flatten(SequencesKt.sequenceOf(new Sequence[] { paramSequence, SequencesKt.sequenceOf(new Object[] { paramT }) }));
  }
  
  public static final <T> Sequence<T> plus(Sequence<? extends T> paramSequence1, Sequence<? extends T> paramSequence2)
  {
    Intrinsics.checkNotNullParameter(paramSequence1, "<this>");
    Intrinsics.checkNotNullParameter(paramSequence2, "elements");
    return SequencesKt.flatten(SequencesKt.sequenceOf(new Sequence[] { paramSequence1, paramSequence2 }));
  }
  
  public static final <T> Sequence<T> plus(Sequence<? extends T> paramSequence, T[] paramArrayOfT)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramArrayOfT, "elements");
    return SequencesKt.plus(paramSequence, (Iterable)ArraysKt.asList(paramArrayOfT));
  }
  
  private static final <T> Sequence<T> plusElement(Sequence<? extends T> paramSequence, T paramT)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return SequencesKt.plus(paramSequence, paramT);
  }
  
  public static final <S, T extends S> S reduce(Sequence<? extends T> paramSequence, Function2<? super S, ? super T, ? extends S> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "operation");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      for (paramSequence = localIterator.next(); localIterator.hasNext(); paramSequence = paramFunction2.invoke(paramSequence, localIterator.next())) {}
      return paramSequence;
    }
    throw new UnsupportedOperationException("Empty sequence can't be reduced.");
  }
  
  public static final <S, T extends S> S reduceIndexed(Sequence<? extends T> paramSequence, Function3<? super Integer, ? super S, ? super T, ? extends S> paramFunction3)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction3, "operation");
    Iterator localIterator = paramSequence.iterator();
    if (localIterator.hasNext())
    {
      int i = 1;
      paramSequence = localIterator.next();
      while (localIterator.hasNext())
      {
        if (i < 0) {
          CollectionsKt.throwIndexOverflow();
        }
        paramSequence = paramFunction3.invoke(Integer.valueOf(i), paramSequence, localIterator.next());
        i++;
      }
      return paramSequence;
    }
    throw new UnsupportedOperationException("Empty sequence can't be reduced.");
  }
  
  public static final <S, T extends S> S reduceIndexedOrNull(Sequence<? extends T> paramSequence, Function3<? super Integer, ? super S, ? super T, ? extends S> paramFunction3)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction3, "operation");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    int i = 1;
    paramSequence = localIterator.next();
    while (localIterator.hasNext())
    {
      if (i < 0) {
        CollectionsKt.throwIndexOverflow();
      }
      paramSequence = paramFunction3.invoke(Integer.valueOf(i), paramSequence, localIterator.next());
      i++;
    }
    return paramSequence;
  }
  
  public static final <S, T extends S> S reduceOrNull(Sequence<? extends T> paramSequence, Function2<? super S, ? super T, ? extends S> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "operation");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    for (paramSequence = localIterator.next(); localIterator.hasNext(); paramSequence = paramFunction2.invoke(paramSequence, localIterator.next())) {}
    return paramSequence;
  }
  
  public static final <T> Sequence<T> requireNoNulls(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    SequencesKt.map(paramSequence, (Function1)new Lambda(paramSequence)
    {
      final Sequence<T> $this_requireNoNulls;
      
      public final T invoke(T paramAnonymousT)
      {
        if (paramAnonymousT != null) {
          return paramAnonymousT;
        }
        throw new IllegalArgumentException("null element found in " + this.$this_requireNoNulls + '.');
      }
    });
  }
  
  public static final <T, R> Sequence<R> runningFold(final Sequence<? extends T> paramSequence, R paramR, final Function2<? super R, ? super T, ? extends R> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "operation");
    SequencesKt.sequence((Function2)new RestrictedSuspendLambda(paramR, paramSequence)
    {
      final R $initial;
      private Object L$0;
      Object L$1;
      Object L$2;
      int label;
      
      public final Continuation<Unit> create(Object paramAnonymousObject, Continuation<?> paramAnonymousContinuation)
      {
        paramAnonymousContinuation = new 1(this.$initial, paramSequence, paramFunction2, paramAnonymousContinuation);
        paramAnonymousContinuation.L$0 = paramAnonymousObject;
        return (Continuation)paramAnonymousContinuation;
      }
      
      public final Object invoke(SequenceScope<? super R> paramAnonymousSequenceScope, Continuation<? super Unit> paramAnonymousContinuation)
      {
        return ((1)create(paramAnonymousSequenceScope, paramAnonymousContinuation)).invokeSuspend(Unit.INSTANCE);
      }
      
      public final Object invokeSuspend(Object paramAnonymousObject)
      {
        Object localObject6 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
        switch (this.label)
        {
        default: 
          throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        case 2: 
          localObject2 = this;
          localObject3 = (Iterator)((1)localObject2).L$2;
          localObject1 = ((1)localObject2).L$1;
          localObject4 = (SequenceScope)((1)localObject2).L$0;
          ResultKt.throwOnFailure(paramAnonymousObject);
          paramAnonymousObject = localObject1;
          break;
        case 1: 
          localObject1 = (SequenceScope)this.L$0;
          ResultKt.throwOnFailure(paramAnonymousObject);
          paramAnonymousObject = localObject1;
          break;
        case 0: 
          ResultKt.throwOnFailure(paramAnonymousObject);
          localObject1 = (SequenceScope)this.L$0;
          localObject3 = this.$initial;
          localObject2 = (Continuation)this;
          this.L$0 = localObject1;
          this.label = 1;
          paramAnonymousObject = localObject1;
          if (((SequenceScope)localObject1).yield(localObject3, (Continuation)localObject2) == localObject6) {
            return localObject6;
          }
          break;
        }
        Object localObject2 = this;
        Object localObject4 = ((1)localObject2).$initial;
        Object localObject3 = paramSequence.iterator();
        Object localObject1 = paramAnonymousObject;
        paramAnonymousObject = localObject4;
        while (((Iterator)localObject3).hasNext())
        {
          localObject4 = ((Iterator)localObject3).next();
          Object localObject5 = paramFunction2.invoke(paramAnonymousObject, localObject4);
          Continuation localContinuation = (Continuation)localObject2;
          ((1)localObject2).L$0 = localObject1;
          ((1)localObject2).L$1 = localObject5;
          ((1)localObject2).L$2 = localObject3;
          ((1)localObject2).label = 2;
          paramAnonymousObject = localObject5;
          localObject4 = localObject1;
          if (((SequenceScope)localObject1).yield(localObject5, localContinuation) == localObject6) {
            return localObject6;
          }
          localObject1 = localObject4;
        }
        return Unit.INSTANCE;
      }
    });
  }
  
  public static final <T, R> Sequence<R> runningFoldIndexed(final Sequence<? extends T> paramSequence, R paramR, final Function3<? super Integer, ? super R, ? super T, ? extends R> paramFunction3)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction3, "operation");
    SequencesKt.sequence((Function2)new RestrictedSuspendLambda(paramR, paramSequence)
    {
      final R $initial;
      int I$0;
      private Object L$0;
      Object L$1;
      Object L$2;
      int label;
      
      public final Continuation<Unit> create(Object paramAnonymousObject, Continuation<?> paramAnonymousContinuation)
      {
        paramAnonymousContinuation = new 1(this.$initial, paramSequence, paramFunction3, paramAnonymousContinuation);
        paramAnonymousContinuation.L$0 = paramAnonymousObject;
        return (Continuation)paramAnonymousContinuation;
      }
      
      public final Object invoke(SequenceScope<? super R> paramAnonymousSequenceScope, Continuation<? super Unit> paramAnonymousContinuation)
      {
        return ((1)create(paramAnonymousSequenceScope, paramAnonymousContinuation)).invokeSuspend(Unit.INSTANCE);
      }
      
      public final Object invokeSuspend(Object paramAnonymousObject)
      {
        Object localObject5 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
        Object localObject4;
        switch (this.label)
        {
        default: 
          throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        case 2: 
          localObject1 = this;
          i = ((1)localObject1).I$0;
          localObject2 = (Iterator)((1)localObject1).L$2;
          localObject3 = ((1)localObject1).L$1;
          localObject4 = (SequenceScope)((1)localObject1).L$0;
          ResultKt.throwOnFailure(paramAnonymousObject);
          paramAnonymousObject = localObject3;
          break;
        case 1: 
          localObject1 = (SequenceScope)this.L$0;
          ResultKt.throwOnFailure(paramAnonymousObject);
          paramAnonymousObject = localObject1;
          break;
        case 0: 
          ResultKt.throwOnFailure(paramAnonymousObject);
          localObject1 = (SequenceScope)this.L$0;
          localObject2 = this.$initial;
          localObject3 = (Continuation)this;
          this.L$0 = localObject1;
          this.label = 1;
          paramAnonymousObject = localObject1;
          if (((SequenceScope)localObject1).yield(localObject2, (Continuation)localObject3) == localObject5) {
            return localObject5;
          }
          break;
        }
        Object localObject1 = this;
        Object localObject3 = ((1)localObject1).$initial;
        Object localObject2 = paramSequence.iterator();
        int i = 0;
        while (((Iterator)localObject2).hasNext())
        {
          Object localObject6 = ((Iterator)localObject2).next();
          localObject4 = paramFunction3;
          int j = i + 1;
          if (i < 0) {
            CollectionsKt.throwIndexOverflow();
          }
          localObject3 = ((Function3)localObject4).invoke(Boxing.boxInt(i), localObject3, localObject6);
          localObject4 = (Continuation)localObject1;
          ((1)localObject1).L$0 = paramAnonymousObject;
          ((1)localObject1).L$1 = localObject3;
          ((1)localObject1).L$2 = localObject2;
          ((1)localObject1).I$0 = j;
          ((1)localObject1).label = 2;
          if (((SequenceScope)paramAnonymousObject).yield(localObject3, (Continuation)localObject4) == localObject5) {
            return localObject5;
          }
          i = j;
          localObject4 = paramAnonymousObject;
          paramAnonymousObject = localObject3;
          localObject3 = paramAnonymousObject;
          paramAnonymousObject = localObject4;
        }
        return Unit.INSTANCE;
      }
    });
  }
  
  public static final <S, T extends S> Sequence<S> runningReduce(Sequence<? extends T> paramSequence, final Function2<? super S, ? super T, ? extends S> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "operation");
    SequencesKt.sequence((Function2)new RestrictedSuspendLambda(paramSequence, paramFunction2)
    {
      final Sequence<T> $this_runningReduce;
      private Object L$0;
      Object L$1;
      Object L$2;
      int label;
      
      public final Continuation<Unit> create(Object paramAnonymousObject, Continuation<?> paramAnonymousContinuation)
      {
        paramAnonymousContinuation = new 1(this.$this_runningReduce, paramFunction2, paramAnonymousContinuation);
        paramAnonymousContinuation.L$0 = paramAnonymousObject;
        return (Continuation)paramAnonymousContinuation;
      }
      
      public final Object invoke(SequenceScope<? super S> paramAnonymousSequenceScope, Continuation<? super Unit> paramAnonymousContinuation)
      {
        return ((1)create(paramAnonymousSequenceScope, paramAnonymousContinuation)).invokeSuspend(Unit.INSTANCE);
      }
      
      public final Object invokeSuspend(Object paramAnonymousObject)
      {
        Object localObject5 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
        Object localObject1;
        Iterator localIterator;
        Object localObject3;
        Object localObject4;
        switch (this.label)
        {
        default: 
          throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        case 2: 
          localObject2 = this;
          localObject1 = ((1)localObject2).L$2;
          localIterator = (Iterator)((1)localObject2).L$1;
          localObject3 = (SequenceScope)((1)localObject2).L$0;
          ResultKt.throwOnFailure(paramAnonymousObject);
          paramAnonymousObject = localObject1;
          break;
        case 1: 
          localObject2 = this.L$2;
          localIterator = (Iterator)this.L$1;
          localObject1 = (SequenceScope)this.L$0;
          ResultKt.throwOnFailure(paramAnonymousObject);
          paramAnonymousObject = localObject2;
          break;
        case 0: 
          ResultKt.throwOnFailure(paramAnonymousObject);
          localObject2 = (SequenceScope)this.L$0;
          localIterator = this.$this_runningReduce.iterator();
          if (!localIterator.hasNext()) {
            break label297;
          }
          localObject3 = localIterator.next();
          localObject4 = (Continuation)this;
          this.L$0 = localObject2;
          this.L$1 = localIterator;
          this.L$2 = localObject3;
          this.label = 1;
          paramAnonymousObject = localObject3;
          localObject1 = localObject2;
          if (((SequenceScope)localObject2).yield(localObject3, (Continuation)localObject4) == localObject5) {
            return localObject5;
          }
          break;
        }
        Object localObject2 = this;
        while (localIterator.hasNext())
        {
          localObject4 = paramFunction2.invoke(paramAnonymousObject, localIterator.next());
          Continuation localContinuation = (Continuation)localObject2;
          ((1)localObject2).L$0 = localObject1;
          ((1)localObject2).L$1 = localIterator;
          ((1)localObject2).L$2 = localObject4;
          ((1)localObject2).label = 2;
          paramAnonymousObject = localObject4;
          localObject3 = localObject1;
          if (((SequenceScope)localObject1).yield(localObject4, localContinuation) == localObject5) {
            return localObject5;
          }
          localObject1 = localObject3;
        }
        label297:
        return Unit.INSTANCE;
      }
    });
  }
  
  public static final <S, T extends S> Sequence<S> runningReduceIndexed(Sequence<? extends T> paramSequence, final Function3<? super Integer, ? super S, ? super T, ? extends S> paramFunction3)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction3, "operation");
    SequencesKt.sequence((Function2)new RestrictedSuspendLambda(paramSequence, paramFunction3)
    {
      final Sequence<T> $this_runningReduceIndexed;
      int I$0;
      private Object L$0;
      Object L$1;
      Object L$2;
      int label;
      
      public final Continuation<Unit> create(Object paramAnonymousObject, Continuation<?> paramAnonymousContinuation)
      {
        paramAnonymousContinuation = new 1(this.$this_runningReduceIndexed, paramFunction3, paramAnonymousContinuation);
        paramAnonymousContinuation.L$0 = paramAnonymousObject;
        return (Continuation)paramAnonymousContinuation;
      }
      
      public final Object invoke(SequenceScope<? super S> paramAnonymousSequenceScope, Continuation<? super Unit> paramAnonymousContinuation)
      {
        return ((1)create(paramAnonymousSequenceScope, paramAnonymousContinuation)).invokeSuspend(Unit.INSTANCE);
      }
      
      public final Object invokeSuspend(Object paramAnonymousObject)
      {
        Object localObject5 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
        Object localObject2;
        switch (this.label)
        {
        default: 
          throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        case 2: 
          localObject1 = this;
          i = ((1)localObject1).I$0;
          localObject4 = ((1)localObject1).L$2;
          localObject3 = (Iterator)((1)localObject1).L$1;
          localObject2 = (SequenceScope)((1)localObject1).L$0;
          ResultKt.throwOnFailure(paramAnonymousObject);
          paramAnonymousObject = localObject4;
          break;
        case 1: 
          localObject3 = this.L$2;
          localObject1 = (Iterator)this.L$1;
          localObject2 = (SequenceScope)this.L$0;
          ResultKt.throwOnFailure(paramAnonymousObject);
          paramAnonymousObject = localObject3;
          break;
        case 0: 
          ResultKt.throwOnFailure(paramAnonymousObject);
          localObject4 = (SequenceScope)this.L$0;
          localObject1 = this.$this_runningReduceIndexed.iterator();
          if (!((Iterator)localObject1).hasNext()) {
            break label343;
          }
          localObject3 = ((Iterator)localObject1).next();
          Continuation localContinuation = (Continuation)this;
          this.L$0 = localObject4;
          this.L$1 = localObject1;
          this.L$2 = localObject3;
          this.label = 1;
          paramAnonymousObject = localObject3;
          localObject2 = localObject4;
          if (((SequenceScope)localObject4).yield(localObject3, localContinuation) == localObject5) {
            return localObject5;
          }
          break;
        }
        Object localObject4 = this;
        int i = 1;
        Object localObject3 = localObject1;
        Object localObject1 = localObject4;
        while (((Iterator)localObject3).hasNext())
        {
          localObject4 = paramFunction3;
          int j = i + 1;
          if (i < 0) {
            CollectionsKt.throwIndexOverflow();
          }
          paramAnonymousObject = ((Function3)localObject4).invoke(Boxing.boxInt(i), paramAnonymousObject, ((Iterator)localObject3).next());
          localObject4 = (Continuation)localObject1;
          ((1)localObject1).L$0 = localObject2;
          ((1)localObject1).L$1 = localObject3;
          ((1)localObject1).L$2 = paramAnonymousObject;
          ((1)localObject1).I$0 = j;
          ((1)localObject1).label = 2;
          if (((SequenceScope)localObject2).yield(paramAnonymousObject, (Continuation)localObject4) == localObject5) {
            return localObject5;
          }
          i = j;
        }
        label343:
        return Unit.INSTANCE;
      }
    });
  }
  
  public static final <T, R> Sequence<R> scan(Sequence<? extends T> paramSequence, R paramR, Function2<? super R, ? super T, ? extends R> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "operation");
    return SequencesKt.runningFold(paramSequence, paramR, paramFunction2);
  }
  
  public static final <T, R> Sequence<R> scanIndexed(Sequence<? extends T> paramSequence, R paramR, Function3<? super Integer, ? super R, ? super T, ? extends R> paramFunction3)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction3, "operation");
    return SequencesKt.runningFoldIndexed(paramSequence, paramR, paramFunction3);
  }
  
  public static final <T> T single(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    paramSequence = paramSequence.iterator();
    if (paramSequence.hasNext())
    {
      Object localObject = paramSequence.next();
      if (!paramSequence.hasNext()) {
        return (T)localObject;
      }
      throw new IllegalArgumentException("Sequence has more than one element.");
    }
    throw new NoSuchElementException("Sequence is empty.");
  }
  
  public static final <T> T single(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    Object localObject = null;
    int i = 0;
    Iterator localIterator = paramSequence.iterator();
    paramSequence = (Sequence<? extends T>)localObject;
    while (localIterator.hasNext())
    {
      localObject = localIterator.next();
      if (((Boolean)paramFunction1.invoke(localObject)).booleanValue()) {
        if (i == 0)
        {
          paramSequence = (Sequence<? extends T>)localObject;
          i = 1;
        }
        else
        {
          throw new IllegalArgumentException("Sequence contains more than one matching element.");
        }
      }
    }
    if (i != 0) {
      return paramSequence;
    }
    throw new NoSuchElementException("Sequence contains no element matching the predicate.");
  }
  
  public static final <T> T singleOrNull(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Iterator localIterator = paramSequence.iterator();
    if (!localIterator.hasNext()) {
      return null;
    }
    paramSequence = localIterator.next();
    if (localIterator.hasNext()) {
      return null;
    }
    return paramSequence;
  }
  
  public static final <T> T singleOrNull(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    Object localObject = null;
    int i = 0;
    Iterator localIterator = paramSequence.iterator();
    paramSequence = (Sequence<? extends T>)localObject;
    while (localIterator.hasNext())
    {
      localObject = localIterator.next();
      if (((Boolean)paramFunction1.invoke(localObject)).booleanValue())
      {
        if (i != 0) {
          return null;
        }
        paramSequence = (Sequence<? extends T>)localObject;
        i = 1;
      }
    }
    if (i == 0) {
      return null;
    }
    return paramSequence;
  }
  
  public static final <T extends Comparable<? super T>> Sequence<T> sorted(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    (Sequence)new Sequence()
    {
      final Sequence<T> $this_sorted;
      
      public Iterator<T> iterator()
      {
        List localList = SequencesKt.toMutableList(this.$this_sorted);
        CollectionsKt.sort(localList);
        return localList.iterator();
      }
    };
  }
  
  public static final <T, R extends Comparable<? super R>> Sequence<T> sortedBy(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    return SequencesKt.sortedWith(paramSequence, (Comparator)new ComparisonsKt__ComparisonsKt.compareBy.2(paramFunction1));
  }
  
  public static final <T, R extends Comparable<? super R>> Sequence<T> sortedByDescending(Sequence<? extends T> paramSequence, Function1<? super T, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    return SequencesKt.sortedWith(paramSequence, (Comparator)new ComparisonsKt__ComparisonsKt.compareByDescending.1(paramFunction1));
  }
  
  public static final <T extends Comparable<? super T>> Sequence<T> sortedDescending(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return SequencesKt.sortedWith(paramSequence, ComparisonsKt.reverseOrder());
  }
  
  public static final <T> Sequence<T> sortedWith(Sequence<? extends T> paramSequence, final Comparator<? super T> paramComparator)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramComparator, "comparator");
    (Sequence)new Sequence()
    {
      final Sequence<T> $this_sortedWith;
      
      public Iterator<T> iterator()
      {
        List localList = SequencesKt.toMutableList(this.$this_sortedWith);
        CollectionsKt.sortWith(localList, paramComparator);
        return localList.iterator();
      }
    };
  }
  
  @Deprecated(message="Use sumOf instead.", replaceWith=@ReplaceWith(expression="this.sumOf(selector)", imports={}))
  @DeprecatedSinceKotlin(warningSince="1.5")
  public static final <T> int sumBy(Sequence<? extends T> paramSequence, Function1<? super T, Integer> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      i += ((Number)paramFunction1.invoke(paramSequence.next())).intValue();
    }
    return i;
  }
  
  @Deprecated(message="Use sumOf instead.", replaceWith=@ReplaceWith(expression="this.sumOf(selector)", imports={}))
  @DeprecatedSinceKotlin(warningSince="1.5")
  public static final <T> double sumByDouble(Sequence<? extends T> paramSequence, Function1<? super T, Double> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    double d = 0.0D;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      d += ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue();
    }
    return d;
  }
  
  public static final int sumOfByte(Sequence<Byte> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      i += ((Number)paramSequence.next()).byteValue();
    }
    return i;
  }
  
  public static final double sumOfDouble(Sequence<Double> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    double d = 0.0D;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      d += ((Number)paramSequence.next()).doubleValue();
    }
    return d;
  }
  
  private static final <T> double sumOfDouble(Sequence<? extends T> paramSequence, Function1<? super T, Double> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    double d = 0.0D;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      d += ((Number)paramFunction1.invoke(paramSequence.next())).doubleValue();
    }
    return d;
  }
  
  public static final float sumOfFloat(Sequence<Float> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    float f = 0.0F;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      f += ((Number)paramSequence.next()).floatValue();
    }
    return f;
  }
  
  public static final int sumOfInt(Sequence<Integer> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      i += ((Number)paramSequence.next()).intValue();
    }
    return i;
  }
  
  private static final <T> int sumOfInt(Sequence<? extends T> paramSequence, Function1<? super T, Integer> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      i += ((Number)paramFunction1.invoke(paramSequence.next())).intValue();
    }
    return i;
  }
  
  public static final long sumOfLong(Sequence<Long> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    long l = 0L;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      l += ((Number)paramSequence.next()).longValue();
    }
    return l;
  }
  
  private static final <T> long sumOfLong(Sequence<? extends T> paramSequence, Function1<? super T, Long> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    long l = 0L;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      l += ((Number)paramFunction1.invoke(paramSequence.next())).longValue();
    }
    return l;
  }
  
  public static final int sumOfShort(Sequence<Short> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    int i = 0;
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      i += ((Number)paramSequence.next()).shortValue();
    }
    return i;
  }
  
  private static final <T> int sumOfUInt(Sequence<? extends T> paramSequence, Function1<? super T, UInt> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    int i = UInt.constructor-impl(0);
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      i = UInt.constructor-impl(((UInt)paramFunction1.invoke(paramSequence.next())).unbox-impl() + i);
    }
    return i;
  }
  
  private static final <T> long sumOfULong(Sequence<? extends T> paramSequence, Function1<? super T, ULong> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "selector");
    long l = ULong.constructor-impl(0L);
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      l = ULong.constructor-impl(((ULong)paramFunction1.invoke(paramSequence.next())).unbox-impl() + l);
    }
    return l;
  }
  
  public static final <T> Sequence<T> take(Sequence<? extends T> paramSequence, int paramInt)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    int i;
    if (paramInt >= 0) {
      i = 1;
    } else {
      i = 0;
    }
    if (i != 0)
    {
      if (paramInt == 0) {
        paramSequence = SequencesKt.emptySequence();
      } else if ((paramSequence instanceof DropTakeSequence)) {
        paramSequence = ((DropTakeSequence)paramSequence).take(paramInt);
      } else {
        paramSequence = (Sequence)new TakeSequence(paramSequence, paramInt);
      }
      return paramSequence;
    }
    throw new IllegalArgumentException(("Requested element count " + paramInt + " is less than zero.").toString());
  }
  
  public static final <T> Sequence<T> takeWhile(Sequence<? extends T> paramSequence, Function1<? super T, Boolean> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "predicate");
    return (Sequence)new TakeWhileSequence(paramSequence, paramFunction1);
  }
  
  public static final <T, C extends Collection<? super T>> C toCollection(Sequence<? extends T> paramSequence, C paramC)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramC, "destination");
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      paramC.add(paramSequence.next());
    }
    return paramC;
  }
  
  public static final <T> HashSet<T> toHashSet(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return (HashSet)SequencesKt.toCollection(paramSequence, (Collection)new HashSet());
  }
  
  public static final <T> List<T> toList(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return CollectionsKt.optimizeReadOnlyList(SequencesKt.toMutableList(paramSequence));
  }
  
  public static final <T> List<T> toMutableList(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return (List)SequencesKt.toCollection(paramSequence, (Collection)new ArrayList());
  }
  
  public static final <T> Set<T> toMutableSet(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    LinkedHashSet localLinkedHashSet = new LinkedHashSet();
    paramSequence = paramSequence.iterator();
    while (paramSequence.hasNext()) {
      localLinkedHashSet.add(paramSequence.next());
    }
    return (Set)localLinkedHashSet;
  }
  
  public static final <T> Set<T> toSet(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return SetsKt.optimizeReadOnlySet((Set)SequencesKt.toCollection(paramSequence, (Collection)new LinkedHashSet()));
  }
  
  public static final <T> Sequence<List<T>> windowed(Sequence<? extends T> paramSequence, int paramInt1, int paramInt2, boolean paramBoolean)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return SlidingWindowKt.windowedSequence(paramSequence, paramInt1, paramInt2, paramBoolean, false);
  }
  
  public static final <T, R> Sequence<R> windowed(Sequence<? extends T> paramSequence, int paramInt1, int paramInt2, boolean paramBoolean, Function1<? super List<? extends T>, ? extends R> paramFunction1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction1, "transform");
    return SequencesKt.map(SlidingWindowKt.windowedSequence(paramSequence, paramInt1, paramInt2, paramBoolean, true), paramFunction1);
  }
  
  public static final <T> Sequence<IndexedValue<T>> withIndex(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return (Sequence)new IndexingSequence(paramSequence);
  }
  
  public static final <T, R> Sequence<Pair<T, R>> zip(Sequence<? extends T> paramSequence, Sequence<? extends R> paramSequence1)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramSequence1, "other");
    return (Sequence)new MergingSequence(paramSequence, paramSequence1, (Function2)zip.1.INSTANCE);
  }
  
  public static final <T, R, V> Sequence<V> zip(Sequence<? extends T> paramSequence, Sequence<? extends R> paramSequence1, Function2<? super T, ? super R, ? extends V> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramSequence1, "other");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    return (Sequence)new MergingSequence(paramSequence, paramSequence1, paramFunction2);
  }
  
  public static final <T> Sequence<Pair<T, T>> zipWithNext(Sequence<? extends T> paramSequence)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    return SequencesKt.zipWithNext(paramSequence, (Function2)zipWithNext.1.INSTANCE);
  }
  
  public static final <T, R> Sequence<R> zipWithNext(Sequence<? extends T> paramSequence, final Function2<? super T, ? super T, ? extends R> paramFunction2)
  {
    Intrinsics.checkNotNullParameter(paramSequence, "<this>");
    Intrinsics.checkNotNullParameter(paramFunction2, "transform");
    SequencesKt.sequence((Function2)new RestrictedSuspendLambda(paramSequence, paramFunction2)
    {
      final Sequence<T> $this_zipWithNext;
      private Object L$0;
      Object L$1;
      Object L$2;
      int label;
      
      public final Continuation<Unit> create(Object paramAnonymousObject, Continuation<?> paramAnonymousContinuation)
      {
        paramAnonymousContinuation = new 2(this.$this_zipWithNext, paramFunction2, paramAnonymousContinuation);
        paramAnonymousContinuation.L$0 = paramAnonymousObject;
        return (Continuation)paramAnonymousContinuation;
      }
      
      public final Object invoke(SequenceScope<? super R> paramAnonymousSequenceScope, Continuation<? super Unit> paramAnonymousContinuation)
      {
        return ((2)create(paramAnonymousSequenceScope, paramAnonymousContinuation)).invokeSuspend(Unit.INSTANCE);
      }
      
      public final Object invokeSuspend(Object paramAnonymousObject)
      {
        Object localObject3 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
        2 local2;
        Object localObject2;
        Iterator localIterator;
        Object localObject1;
        switch (this.label)
        {
        default: 
          throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        case 1: 
          local2 = this;
          localObject2 = local2.L$2;
          localIterator = (Iterator)local2.L$1;
          localObject1 = (SequenceScope)local2.L$0;
          ResultKt.throwOnFailure(paramAnonymousObject);
          paramAnonymousObject = localObject2;
          break;
        case 0: 
          ResultKt.throwOnFailure(paramAnonymousObject);
          local2 = this;
          paramAnonymousObject = (SequenceScope)local2.L$0;
          localIterator = local2.$this_zipWithNext.iterator();
          if (!localIterator.hasNext()) {
            return Unit.INSTANCE;
          }
          localObject2 = localIterator.next();
        }
        while (localIterator.hasNext())
        {
          localObject1 = localIterator.next();
          localObject2 = paramFunction2.invoke(localObject2, localObject1);
          Continuation localContinuation = (Continuation)local2;
          local2.L$0 = paramAnonymousObject;
          local2.L$1 = localIterator;
          local2.L$2 = localObject1;
          local2.label = 1;
          if (((SequenceScope)paramAnonymousObject).yield(localObject2, localContinuation) == localObject3) {
            return localObject3;
          }
          localObject2 = localObject1;
          localObject1 = paramAnonymousObject;
          paramAnonymousObject = localObject2;
          localObject2 = paramAnonymousObject;
          paramAnonymousObject = localObject1;
        }
        return Unit.INSTANCE;
      }
    });
  }
}


/* Location:              /home/icat/Documents/digital-awareness/src/undangan-pernikahan-dex2jar.jar!/kotlin/sequences/SequencesKt___SequencesKt.class
 * Java compiler version: 6 (50.0)
 * JD-Core Version:       0.7.1
 */